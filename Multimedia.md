# 멀티미디어


## Analogue to Digital Conversion(ADC)
### 1. 개념
아날로그 신호를 디지털 신호로 변화.

### 2. 아날로그 신호를 디지털화하는 과정
샘플은 아날로그 신호가된다. 

#### 1. Sampling
일정 주기(T)로 아날로그 신호를 잘게 쪼갠것. S(샘플링율) = 10이라면, T=1/10sec이다.
* 주기(T) = 1/S
* Sampling Rate(S) = 1/T  


#### 2. Quantization
Sampling한 데이터를 가장 일정 수치로 해석화한 것.
![image](https://user-images.githubusercontent.com/56042451/192537529-71f088c5-b8d8-489e-961b-fd21ef9d3d9f.png)
quantization step size(△)가 작을 수록 신호의 손실을 감소 시킬 수 있다. = 비트수(bit depth)가 많으면 양자화 스텝 크기가 작아지며 신호 손실은 줄어든다. 하지만 데이터의 크기는 증가한다.

* 양자화 bit-length : bits/samples
* 양자화 : Q(s) = floor(s/△ + 0.5)
* 역양자화 : s' = △\*Q(s)

### 3. Sampling theory
샤넌이 발표한 이론으로 Sampling rate가 주파수대역폭의 2배이상이면 디지털로 변환된 아날로그 신호를 다시 아날로그신호로 복구했을 때 손실없이 복구할 수 있다는 이론이다.

#### Sampling rate(sample/sec) >= 2 * fBW(주파수 대역폭) 

인간이 들을 수 있는 주파수 대역폭은 20~20,000Hz 이므로 Sampling rate가 19980\*2, 약 40000 이상(T=1/40000)이라면, 즉 초당 40000개 이상의 샘플을 봅아내어 디지털 신호로 변환시키면 아날로그 신호로 복호 시켰을 때 손실없이 복호 시킬 수있다.

### 4. 데이터 크기
* 초당 데이터 (bytes/sec) = Sampling rate(samples/sec) * 양자화 bit-length(bytes/sample)

#### 동영상 원본 영상 크기
3 bytes/pixel, 해상도 = 7680x4320 pixels/frame, 총 영상 크기 = 3x76580x4320 bytes/frame (1프레임다 100Mbytes)
24프레임당 60분짜리 영상이라면 8.64Tera bytes/hour이기 때문에 실제로 저장하기에 많은 용량이 필요하기 때문에 압축기술필요
<br></br>
## 데이터 압축
### 1. 개념
#### 정보이론 정보의 크기를 계산하 수 있도록 해주는 이론 -> 수치화(부피, 길이, 온도)
정보이론에 기반하여 계산한 데이터 크기는 실제 저장장치에 많이 저장하기 어렵기 때문에 데이터를 압축하여 효율적으로 저장하도록 해야한다.

#### 정보량
정보가 정확하다면 계산해야하는 데이터의 크기를 적게 표현해도 충분히 표현할 수 있다. 또한 해당 정보가 많이 반복됨을 의미한다(정보의 중복성). 예를들어 내일 태양이 뜬다는 정보는 100% 일어낙 때문에 확률은 1이고 정보량은 0이 된다.  
상자에 카드 A, B가 있을 때, 한 장을 뽑을 때 각 카드의 확률은 1/2이다. 이느 정보량으로 1비트로 0은 A카드 1은 B카드로 표현할 수있다.

#### 엔트로피 이로
어떤 사건 A가 일어날 확률일 때 몇 비트로 표현 가능한지.  
B(p) = -log2(p) bits, 심볼당 평균 비트수 =E(I) = -sig(Pi)\*B(Pi) (bits/symbol)

#### 크로스 엔트로피
정보 i의 원래 확률은 Pi인데 Qi의 확률로 비트르 배당했을 때의 심볼당 평균 비트 수

### 2. 부호화(Encoding)

#### 무손실 부호화(Lossless Encoding)
인코딩 과정을 거치 다시 디코딩 했을 때 원본(I)와 복호 데이터(I')의 Loss가 0이면 무손실 부호화라고한다.

#### 엔트로피 부호화
엔트로피 이론을 기반으로 하는 무손시 부호화로 허프만, 산술 부호화가 있다.

#### Run-Length encoding
심볼과 그 심볼이 연속으로 나오는 개수로 부호화한다. 무손실 부호화다
> I : 33AAAAAARRRR -> (3,2)(A,6)(R,4) -> 33AAAAAARRRR = Lossless encoding

#### Prediction Coding
부호화 할 데이터에서 예측데이터를 뺀 잔차값(Residual)을 부호화 한다. 무손실 부호화다. 예제에서 예측값(Prediction)은 이전 값이라고 가정하고 첫 번째 예측값은 0이라고 가정한다. 단, 예측값이 복호화 할 때 사용되기 때문에 예측값을 따로 담아야한다.
> I : 3 4 4 4 4 5 4 3
> pre 0 3 4 4 4 4 5 4
> res 3 1 0 0 0 1 -1 -1 
> pre 0 3 4 4 4 4 5 4
> I'  3 4 4 4 4 5 4 3

#### 허프만 부호화
1. 심볼의 확률 계산
2. 확률이 가장 적은 것 부터 이진트리를 구성한다.
3. 왼쪽 자식에는 0, 오른쪽 자식에는 1을 부여한다.
4. 루트 노드부터 말단노드까지 나오는 비트 경로를 이으면 각 심볼의 이진코드를 구할 수있다.

허프만 부호화는 상대적으로 심볼당 비트수는 엔트로피 계산값보다 높지만 Prediction encoding처럼 부가 정보(Huff)를 전송할필요가 없음





