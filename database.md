# DATABASE

## Key
관계형 데이터베이스에서 특정 튜플을 식별하기 위한 식별자

### Super Key
### Candidate Key

### Primary Key

### ■ Surrogate key(대리키)
입력 데이터 열로 기본키(자연키)를 사용하지 않고 시스템에서 독자적으로 할당한 키를 의미한다. 일반적으로 일련번호가 사용된다. 
* 이점
	+ 자연키의 저장 공간을 줄여 성능 향상을 도모할 수 있다.
	+ 계좌번호 같은 중요한 자료를 기본키로 사용하지 않아 보안상 이득을 얻을 수 있다.
	+ 변경에 영향을 덜 받기 위해 사용하기도 한다.
	+ 자연키는 변경될 가능성이 조금이라도 존재하지만 대리키는 비즈니스적인 의미가 없기 때문에 변경될 이유가 없다.
* 단점
  + DB 쿼리가 복잡해질 수 있다.

## 인덱스(Index)
RDBMS에서 테이블의 조회 속도를 높여주는 **자료구조**이다.  
테이블의 특정 컬럼에 대한 인덱스를 생성하면, 해당 컬럼의 데이터를 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.(색인화)
이때 **컬럼의 값(INDEX-KEY)** 과 **물리적 주소 값(ROWID)** Key, Value 한 쌍으로 저장된다. **인덱스도 테이블**이다 
![image](https://user-images.githubusercontent.com/56042451/170052944-5a784153-a4eb-43b3-bc50-a1dd46685498.png)

### 특징
* 인덱스는 하나 혹은 여러개의 컬럼으로 설정 가능하다.
* WHERE절을 사용하지 않고 인덱스가 설정된 컬럼을 조회하는 것은 성능에 영향이 없다.

### 인덱스 사용 시 주의할 점
* 비교연산과 범위연산을 사용할 것
  + (=) > (>=) > (between) 순서대로 비교하는 것이 효율적을 인덱스를 조회하는 방법이다.
    - 비교연산과 범위연산을 동시에 사용할 경우 비교연산을 앞에 두어 먼저 조회하는 것이 효율적일 확률이 높다.
* LIKE 사용시 와일드 카드로 시작하지 않아야 인덱스가 작동한다.
  + 와일드 카드로 시작하면 앞에 무슨 단어가 설정될지를 모르니깐 Full Scan 할 것이다.
* 인덱스로 사용된 컬럼을 가공하면 안된다.
  + WHERE EMP_NO +2 < 11000 <- 이런식으로 직접적으로 컬럼을 가공하면 인덱스가 사용되지 않는다.
  + WHERE EMP_NO < 11000 + 2 <- 이건 컬럼을 가공하지 않았기 때문에 가능하다
* 타입이 같아야 한다.
  + 문자열 타입인 컬럼을 숫자로 조회하면 인덱스를 사용하지 않는다.
  + NULL은 IS NULL 조건으로 가능


### 생성 전략
#### 1. 큰 규모의 테이블
인덱스를 무조건적으로 생성한다고해서 좋은 퍼포먼스를 보이는 것은 아니다. 만약 테이블의 크기가 작다면 FULL SCAN이 오히려 더 빠른 경우도 있다. 또한 불필요한 공간을 낭비한다. **5블럭 미만**인 테이블은 인덱스를 생성하지 않는다.
#### 2. INSERT, UPDATE, DELETE가 자주 발생하지 않는 테이블
인덱스를 생성 후 데이터의 변경이 자주 일어난다면 인덱스 크기가 비대해지기 때문에 오히려 성능에 저하가 발생할 수 있다.
#### 3. WHERE나 ORDER BY, JOIN 등이 자주 사용되는 컬럼
인덱스를 생성 후 해당 컬럼으로 WHERE, ORDER BY, JOIN으로 사용하지 않으면 FULL SCAN과 성능이 차이가 없다.  
인덱스로 생성한 해당 컬럼을 **무조건** 사용해야한다.
#### 4. 데이터의 분포도가 좋은 컬럼 == 데이터 중복도가 낮은 컬럼 == 카디널리티가 높다
데이터의 분포도가 15% 이상인 컬럼은 인덱스를 생성했을 시 평균적으로 수행속도가 느려진다고 한다.  
* 분포도가 좋은 컬럼이 없을때
  + 여러 컬럼을 결합하여 분포도를 좋게 만든다.
#### 5. 항상 '=' 으로 비교되는 컬럼
인덱스는 = 비교연산으로 사용해야 성능의 향상을 기대할 수 있다.
#### 6. 유일한 컬럼

### 인덱스 설정 후 데이터 추가, 수정 및 변경
인덱스를 지정하게되면 UPDATE, DELETE 연산도 조회 후 작업을 실행하기 때문에 성능이 향상된다. 하지만 데이터를 변경 후 인덱스 속도는 보장하지 못한다.
* INSERT
  - 데이터를 추가하는 경우 새로운 데이터에 대한 인덱스를 추가해야한다.
* UPDATE
  - 데이터를 수정하는 경우 기존의 인덱스는 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가
* DELETE
  - 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
데이터를 수정하는 경우 인덱스를 제거하는 것이 아닌 **'사용을 안함'** 으로 처리하기 때문에 필요없는 공간을 낭비하게되고 지속적으로 수정작업이 이루어진다면 인덱스의 크기가 비대해질 수 있다.  
인덱스도 사용하면서 지속적인 데이터의 업데이트가 이루어질 경우 **최신 상태의 인덱스**를 유지해야한다. 

### 단점
* 인덱스는 정렬된 상태를 유지해야하기 때문에 INSERT, UPDATE, DELETE 작업이 이루어지면 다시 INDEX를 재구성 해야한다.
* 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에만 효율적이다.
  + 전체를 조회하는 경우는 결국 FULL SCAN 이다. INDEX를 처리하는 의미가 없다.
* 인덱스를 생성하게되면 전체 테이블의 공간 중 약 10% 정도 공간이 더 필요하다.

### SQL
```mysql
#단일 인덱스 생성
CREATE INDEX idx_emp1 ON employees(emp_no);
#복합 인덱스 생성
CREATE INDEX idx_emp2 ON employees(emp_no, birth_date);
#유니크 인덱스 생성

#인덱스 삭제
DROP INDEX idx_emp1;
```

### 종류
#### 1. 클러스터형 인덱스 (Cluster Index)

#### 2. 보조 인덱스 (Sub Index)

### 선택성 (Selectivity)
선택성이 좋다는 것은 원하는 값을 잘 가져올 수 있다라는 것이다. 원하는 값을 잘 가져오려면 데이터의 분포도가 낮아야된다. 데이터의 분포도가 낮을려면 중복된 값이 적으면 적을수록 분포도는 낮게된다.
#### 1. 분포도 계산
분포도 = 1/(해당 컬럼의 중복된 데이터를 제거한 후 데이터 수) \* 100
```mysql
select (1/cnt) * 100
```
* 분포도가 좋다 = 선택성이 좋다 = 데이터의 중복이 거의 없다
* 분포도가 않좋다 = 선택성이 않좋다 = 데이터의 중복이 많다.

## Data Modeling
### 정의
 현실 세계의 작업이나 사물을 데이터베이스로 표현하는 작업, 데이터 베이스 모델링은 테이블간 관계로 표현한다.

### 생명주기(Life Cycle)
1. 요구사항 수집 및 분석
2. 설계
3. 구현
4. 운영
5. 감시 및 개선

* **요구사항 분석**
  + 사용자들의 요구사항을 듣고 분석하여 데이터베이스의 **구축 범위**를 결정한다.
* **설계**
  + 개념적 모델링 : 핵심 Entity 도출 및 ERD(Entity Relationship Diagram) 작성
  + 논리적 모델링 : ERD-RDB 모델 사상, 상세 속성 정의, 정규화
  + 물리적 모델링 : DB 개체 정의, 테이블 및 인덱스 설계
* **구현**
  + DBMS에 실질 적으로 구현하는 단계이다. 
### 1. 요구사항 수집 및 분석
사용자가 원하는 데이터베이스에 대한 정보를 수집하고, 데이터베이스에 영향을 주는 다양한 요소에 대해 구상한다. 

### 2. 설계

#### 2-1 개념적 모델링
개체(Entity)와 개체간 관계(Relationship)를 정의 하고 현실 세계의 데이터를 개념적으로 표현하여 개념적 구조를 형성하는 것을 말한다.  
개념적 구조를 형성하는 과정이기 때문에 추상화 수준이 높고 포괄적인 수준의 모델링을 수행한다. 개념적 모델을 표현하기 위해 ERD(Entity-Relationship Diagram)을 생성한다. 
* ㅁ Entity -> Table
* O  Atrriibute -> Column
* ◇ Relation -> PK, FK
* Tuple -> Row  
![image](https://user-images.githubusercontent.com/56042451/169429954-9b3ab6d2-8883-403f-8972-ce7c1271824e.png)

### 2-3 논리적 모델링
개념적 모델링을 수행 후 실시하는 단계로써, 개념적 모델링에서 추출된 Entity와 Attribute들의 관계를 더욱 구조적으로 설계하는 단계를 말한다. **Scheme** 설계의 단계라고도 한다. 
* 세부적인 Attribute 추출
 + 개념적 모델링에서는 핵심 속성만 추출한다. 고객 Entity에서 개념적 모델링은 이름, 주소, 전화번호로 큰 틀의 Attribute만 추출했다면 논리적 모델링에서는 성별, 나이 등 세부적인 Attribute까지 추출한다.
* 정규화 수행
 + 데이터가 중복 저장되거나, 갱신, 삭제, 삽입 이상을 제거한다.
* 데이터 표준화 수행
 + 데이터 용어 사전(Dictionary)와 도메인을 정의하여 동일하게 사용되는 용어 정리 및 데이터의 형태와 크기를 확정한다.

논리적 모델링의 **핵심 키**의 설정과 **정규화** 작업이다.
* Scheme : Entity의 구조에 대한 명세

### 2-3 물리적 모델링
논리적 모델링까지 완성된 모델을 DBMS와 하드웨어 특성을 고려하여 물리적으로 Scheme를 추국하는 것이다. 물리적 모델링에서는 View, Trigger, index, Stored Procedure, Function 등을 작업하게 된다. 그리고 성능을 향상시키기 위해 **역정규화** 과정도 실시할 수 있다.

### 개체-관계 다이어그램(Entity-Relationship Diagram)
데이터 모델링 과정 중 개념적 모델링에서 사용하는 모델, Peter Chen이 제한하였다.

* 개체(Entity)
 + 독립적인 의미를 지니고 있는 우뮤형의 사람 또는 사물을 일컫는다. 보통 DBMS에서 테이블로 작성되는 것이다.
* 속성(Attribute)
 + 개체의 가질 수 있는 어떤 특성을 나타낸다. DBMS에서 Column으로 작성된다.
* 관계(Relation)
 + 개체와 개체간의 어떤 조건으로 연결하는 것이다. 관계는 크게 1:1, 1:N, N:N 등이 존재한다.

#### 개체(Entity)
개체(Entity)는 사람, 사물, 장소, 개념, 사건과 같이 유무형의 정보를 가지고 있는 독립적인 실체를 말한다.  

* 개체 타입(Entity type)
  + 개체를 고유한 이름과 속성들로 정의한 것
* 개체 인스턴스(Entity instance)
  + 개체를 구성하고 속성들의 값을 가져 실체화된 개체
* 개체 집합(Entity Set)
  + 특정 개체 타입에 대한 개체 인스턴스의 모임  
![image](https://user-images.githubusercontent.com/56042451/169695103-f296430d-102d-4cba-b240-a4257e3e93f5.png)

* 개체의 특성
  + 유일한 식별자에 의해 식별이 가능해야한다.
  + 꾸준한 관리를 필요하는 정보이다.
  + 두 개 이상 영속적으로 존재한다.
  + 업무 프로세스에 이용된다.
  + 반드시 자신의 특징을 나타내는 속성을 포함한다.
  + 다른 개체와 최소 한 개 이상의 관계를 맺고있다.
 
* 개체의 종류
  + 강한 개체 (Strong Entity)
    - 다른 개체의 도움 없이 독자적으로 존재하는 개체, 일반적으로 개체라고 말하는 것은 강한 개체를 일컫는다.
    - 독립적으로 식별할 수 있는 **Primary Key**를 가지고 있는 개체 타입
  + 약한 개체 (Week Entity)
    - 독자적으로 존재가 불가능하고 반드시 상위개념의 개체가 존재해야한다.
    - **PK키가 없는** 개체, 강한 개체 타입의 PK키를 상속받아 사용하거나, 상속받은 PK키와 결합하여 사용한다.
    - 약한 개체의 PK 속성을 **식별자(discriminator)** 혹은 **부분키(Partial Key)** 라고 한다.  
    예시) 고객 관계에서 고객은 강한 개체지만 계좌는 고객이 존재해야 존재할 수 있으므로 계좌 개체는 약한 개체이다.  
![image](https://user-images.githubusercontent.com/56042451/169698781-7fc1c488-19bb-4123-903a-0e756cf478f0.png)

#### 속성(Attribute)
개체가 가질 수 있는 어떤 성질 또는 특성이다  
도서 개체가 가질 수 있는 속성은 도서번호, 도서이름, 출판사가 존재한다.

* 유형
  + 단순속성(Simple Attribute)
    - 더 이상 분해가 불가능한 속성, 원자값, 일반적인 속성이라면 단순속성이다.
  + 복합속성(Composit Attribute)
    - 독립적인 의미를 가진 속성으로 단순속성으로 분해할 수 있는 속성  예) 주소 -> 시, 동 단위로 구분가능하다.
    - 복합속성의 판단은 복합속성을 나눈 값들이 업무에 사용되느냐의 여부에 따라 기준이 되기도한다.  
![image](https://user-images.githubusercontent.com/56042451/169695778-b275096c-9585-4eb1-8e25-4e148eeb4337.png)

  + 단일값 속성(Single-valued Attribute)
    - 하나의 값만 가지는 속성  
    예) 학생 개체에서 학번은 학생마다 단 1개씩만 가진다.
  + 다중값 속성(Multi-valued Attribute)
    - 여러의 값을 가지는 속성  
    예) 학생 개체에서 학생의 취미는 여러개의 값을 가질 수 있다.  
![image](https://user-images.githubusercontent.com/56042451/169695799-b326bcdd-9395-4f71-97b1-5beb51e03481.png)

  + 저장속성(Stored Attribute)
    - 다른 속성의 영향없이 단독으로 저장되는 속성  
    예) 가격과 할인은 초기 입력된 값으로 강제 변경하지 않는 이상은 변경이 되지않는다.
  + 유도속성(Derived Attribute)
    - 다른 저장 속성으로부터 유도(계산)된 속성  
    예) 판매가격은 가격과 할인에 의해 계산되어 저장된다.
![image](https://user-images.githubusercontent.com/56042451/169695898-fb710b87-0598-46a4-a0d8-d4a5d6dab990.png)

  + 키 속성(Key Attribute)
    - 속성이 개체를 유일하게 식별가능하다면 키 속성이다. 해당 속성에 밑줄을 그어 키속성을 나타낸다.  
    ![image](https://user-images.githubusercontent.com/56042451/169696036-f0810f31-29ae-4ba5-ab14-df98747631e1.png)

### 관계(Relationship)
개체 사이 연관성을 나타내는 개념이다. 관계를 더 세부적으로 나타내기위해 Attribute를 가질 수있다.
![image](https://user-images.githubusercontent.com/56042451/169696938-f83c80f4-0c08-4e1f-af37-c288ea5567b6.png)

* 관계타입(Relation type)
  + 개체타입과 개체타입 간의 연결 가능한 관계를 정의한 것
* 관계집합(Relation Set)
  - 관계로 연결된 집합  
 ![image](https://user-images.githubusercontent.com/56042451/169696696-6451050d-424b-4607-a790-f02337ef4e17.png)

#### 관계타입 유형

* 차수에 따른 유형  
  관계 집합에 참가하는 개체 타입의 수를 관계타입의 차수(Degree)라고 한다.
  + 1진 관계 = 순환적 관계(recursive relationship)
    - 한 개체가 자기 자신과 관계를 맺음  
    예) 학생 Entity가 서로 멘티, 멘토의 관계를 맺을 때 1진 관계로 표현할 수 있다.  
    ![image](https://user-images.githubusercontent.com/56042451/169697211-5ea5f966-2483-475b-9370-f141c82c3c2c.png)
  + 2진 관계(Binary relationship)
    - 두 개체가 관계를 맺는 것  
    ![image](https://user-images.githubusercontent.com/56042451/169697274-c6fb220c-a33d-4c41-bfa2-00dbe3497e68.png)
  + 3진 관계(Ternary relationship)
    - 세 개의 개체가 관계를 맺는 것  
    ![image](https://user-images.githubusercontent.com/56042451/169697326-25fb16bf-c80a-4f7b-9b66-025a1363bd47.png)

* 관계 대응 수에 따른 유형  
  관계는 개체 간의 상호 작용을 표현하고, 관계 대응 수(Cardinality)는 두 개체 타입의 관계에 실제 관계에 참여하는 개별 개체수를 의미한다.
  + 1대1(OneToOne, 1:1)
    - 개체 간 실제 관계에 참여하는 수가 1:1로 대응하는 관계  
    예) 사원 당 하나의 컴퓨터만 배분된다.  
  ![image](https://user-images.githubusercontent.com/56042451/169697569-4812db06-e628-45de-ab8b-ff7b96feb022.png)
  + 1대다(OneToMany, 1:N) or 다대1(ManyToOne, N:1)
    - 한쪽 개체 타입의 개체 하나가 다른 개체타입의 개체 여러개와 관계를 맺는 경우, N은 0 이상의 자연수를 말한다.
    예) 사원 한 사람 당 여러 개의 컴퓨터가 배분된다.   
  ![image](https://user-images.githubusercontent.com/56042451/169697735-7f93f805-fb96-4f7b-af16-e5ddd533f88c.png)
  + 다대다(ManyToMany, N:M)
    - 각 개체 타입의 개체들이 서로 임의의 개수의 개체들과 서로 복합적인 관계를 맺고있는 경우  
    예) 직원들은 여러 프로젝트에 참가 할 수 있다.  
  ![image](https://user-images.githubusercontent.com/56042451/169697822-21753ac4-1ffb-4eab-9421-1605910eb60d.png)
  
  * 관계에서 'One' 측면은 Primary Key로 구성하고 'Many' 측면은 One 측의 PK를 Foriegn Key로 구성한다.
  * **Many-to-many**는 위에 예시와 같이 구현하는 것은 쉽지 않다. 새로운 Entity를 생성하여 아래 예와 같이 대상 Entity를 1:N관계로 표현하여 구현한다.  ![image](https://user-images.githubusercontent.com/56042451/169431313-27367cb4-9b9c-416a-95ef-1c6a21609980.png)

#### ISA 관계 (Is-a Relationship)
관계 중에 상하 관계를 보이는 관계가 있다. 상위 개체 타입의 특성에 따라 하위 개체 타입이 결정되는 형태이다.  
상위 개체 타입은 **슈퍼클래스**, 하위 개체 타입은 **서브 클래스** 라고 한다.  
![image](https://user-images.githubusercontent.com/56042451/169697977-b4e837c1-a565-4b96-8a1a-a61565b8137e.png)

#### 참여 제약 조건
개체 집합 내 모든 개체가 관계에 참여하는지 유무에 따라 **전체참여**와 **부분참여**로 구분할 수 있다.
* 전체 참여
  + 개체 집합 내의 모든 개체가 관계에 참여 ** 1 이상**
* 부분 참여
  + 개체 집합 내의 개체가 부분 적으로 관계에 참여, 참여 할 수도 안할 수도 있다, **최소 0 이상**
* 예 ) 학생은 모든 강좌를 수강할 필요는 없으므로 부분참여, 강좌는 폐강이 안된다고 할 시 무조건 참여해야하므로 전체참여가 된다.  
![image](https://user-images.githubusercontent.com/56042451/169698264-969a2403-d154-4ed3-9995-0c8b53a4502a.png)

#### 역할
개체 타입 간의 관계를 표현할 때 각 개체들은 고유한 역할을 담당한다. 일반적으로 역할은 관계만으로도 명료하다면 표시하지 않지만 관계만으로 개체의 역할이 명료하지 않다면 표시를 해야한다.  
![image](https://user-images.githubusercontent.com/56042451/169698322-daede49c-645e-4a0a-9285-a2fb3da4b3ca.png)


## View
한 개 이상의 **기본 테이블**이나 **다른 뷰**를 이용하여 생성되는 **Virtual Table**  
* 뷰는 기존에 생성된 테이블 또는 다른 뷰에 접근할 수 있는 전체 데이터 중에서 일부만 접근할 수 있도록 **제한**하기 위한 방법이다.
* 뷰는 물리적인 데이터 값을 가지지 않는다. view라는 이름에서 알 수 있듯 기존 테이블 데이터를 조회할 수 있는 화면과 같다. 즉 뷰는 물리적인 테이블이 아닌 물리적 테이블의 특정 값에 접근 할 수 있는 **논리적 테이블**이다
* 일반적으로 테이블을 조회하는 문장을 Query문이라고 지칭하지만, 뷰는 테이블이 아니기 때문에 **View Query**라고 한다.
* 뷰는 논리적 테이블이며 참조하는 테이블을 제한적으로 사용할 수 있도록 하는 하나의 Virtual table이다.  
### 뷰를 사용하는 경우
* 특정 데이터 보고서를 작성할 때 데이터베이스에 필요한 Attribute만 가져오고 싶고 매주 보고서를 작성해야한다면 보고서를 위한 테이블을 생성하는 것이아닌 하나의 뷰를 만드는 것이 좋다. 보고서 테이블을 만들 경우 기존 테이블의 데이터가 변경되면 보고서 테이블의 데이터 또한 수정해야한다. 하지만 뷰는 물리적 테이블을 근거로한 **논리적 테이블**이기 때문에 기존 테이블의 데이터를 수정하여도 상관없다.
* 학교의 학생테이블은 특정 직원만 조회가 가능하다. (모든 직원이 다 조회가 가능하면 보안에 대한 우려가 있다.)
### 장점
* **논리적 독립성(Logical data independence) 제공** : 다른 응용프로그램이나 데이터베이스에 영향을 주지않고 원하는 데이터에 접근가능하다.
* **데이터 접근제어** : 특정 데이터만 조회하도록 하므로써 다른 데이터에 접근을 불가능하게 한다.
* **데이터 조작 연산의 간소화** : 응용프로그램이 원하는 뷰를 생성시, 데이터 조작 연산을 간소화 할 수 있다.  
예를 들어 3년 이상인 회원은 VIP회원이라고 4월달에 생일을 맞는 사람을 조회한다면, VIP뷰를 만들어서 VIP뷰에서 생년월일이 4월 달인 회원을 조회하는 것이 좀 더 단순화가 가능하다. 또한 논리적이 테이블이기 때문에 회원이 탈퇴하든 새로 들어오든 뷰에는 영향을 받지 않는다.
* **여러 사용자의 다양한 데이터 요구 지원** : 사용자가 원하는 데이터마다 새로운 테이블로 관리하는 것보다 뷰로 제공하는 것이 효율적이다.
### 단점
* **정의 변경 불가** : 한 번 생성된 뷰는 변경할 수 없다.
* **뷰를 삭제 시 연관된 뷰는 모두 삭제** : 특정 뷰를 삭제하면 그 뷰를 참조하는 또 다른 뷰 또한 삭제된다.
* **삽입, 삭제, 갱신 제한** : 뷰는 조회는 특별한 제약이 없지만 삽입, 삭제, 갱신은 뷰에 구조에 따라 제약사항이 있다.

### 종류
* 단순뷰 : 하나의 기본 테이블로 정의된 뷰
* 복합뷰 : 두 개 이상의 기본 테이블로 정의 된 뷰


### 뷰생성
```sql
CREATE VIEW {뷰명} AS SELECT {열} FROM {테이블명} [조건];

#예제
#고객 번호가 300이상인 뷰
CREATE VIEW OVER300_CUSTOMERS_VIEW AS SELECT * FROM CUSTOMERS
                                    WHERE customerNumber >= 300;
```

* 뷰조회 방법  
  ```sql
  SHOW FULL TABLES; # USE된 데이터베이스의 모든 테이블의 모델과 타입을 테이블형태로 반환 
  SHOW FULL TABLES WHERE Table_type LIKE 'VIEW'; # USE된 데이터베이스의 뷰 정보 반환
  ```
### 뷰삭제
```sql
DROP VIEW {뷰 이름};

#예시
DROP VIEW VIEW_1;
```

### 뷰 종류
**단순뷰(Simple View)** : 하나의 테이블로 생성한 뷰 == JOIN이 없는 뷰
```sql
#단순뷰 예제
#고객 번호가 300이상인 뷰
CREATE VIEW OVER300_CUSTOMERS_VIEW AS SELECT * FROM CUSTOMERS
                                    WHERE customerNumber >= 300;
```
* 특징
  * 하나의 테이블로 생성
  * 테이블 생성시 그룹함수 사용 제약 -> MAX(열명) 이런식으로 사용이 불가능하다. 무조건 별칭(alias)를 지정해줘야함 : MAX(열명) AS 최대 지불수량, Mysql에서는 alias를 지정안해줘도 생성가능한 것같음
    ```sql
     #뷰생성
     CREATE VIEW SUM_PAYMENTS_VIEW AS SELECT customerNumber, SUM(amount) AS 합계 FROM payments GROUP BY customerNumber;
     ```
  * DML 사용이가능, 만약 참조한 테이블에서 제약사항이 걸려있다면 에러
     ```sql
     #뷰생성
     CREATE VIEW MAIN_INFO_VIEW AS SELECT customerNumber, customerName, phone, city FROM customers;
     #INSERT
     INSERT INTO MAIN_INFO_VIEW(customerNumber, customerName, phone, city) VALUES(801, "James", "010-123-123", 'Seoul');
        #참조테이블에서 없는 값은 NULL 값으로 INSERT 된다.
     ```

* **복합뷰(Complex View)** : 여러 개의 테이블로 생성 == JOIN, 또는 SUBQUERY로 만들어진 뷰
```sql
#복합뷰 예제
#주문한 내역이 있는 고객의 이름
CREATE VIEW ORDERS_CUSTOMERS_VIEW AS SELECT C.customerName FROM orders O INNER JOIN customers C
                                                                        ON O.customerNumber = C.customerNumber;
```

|단순뷰|복합뷰|
|:------:|:---:|
|하나의 테이블로 생성|여러 개의 테이블로 생성|
|그룹 함수의 사용이 불가능|그룹 함수의 사용이 가능|
|DISTINCT 사용 불가능|DISTINCT 사용 가능|
|DML 사용이 가능|DML 사용이 불가능


## 이상현상
한 릴레이션에 여러 엔티티의 속성을 혼합하면 정보가 중복 저장되는 경우가 발생 할 수 있다. 데이터의 중복은 관계형 데이터베이스에서 이상현상을 발생시키는 주범이다. 이상현상은 중복된 데이터를 최대한으로 제거하는 작업을 통해 이상현상을 최소한으로 낮출 수 있다. 
### 삽입이상 (Insertion Anomaly)
새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하거나, key가 존재하지 않아 삽입이 불가능한 문제

### 갱신이상 (Update Anomaly)
중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 문제
### 삭제이상 (Deletion Anomal)
튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되어 원하지 않는 정보의 손실이 발생하는 문제
<br></br>
## 함수적 종속성 (Functional Dependency)
어떤 릴레이션의 속성의 부분집합 A, B가 존재할 때 A값이 정해지면 B값이 정해질 때 B는 A에 함수 종속한다하고, 이를 **A->B**라고 한다.
* X는 결정자, Y는 종속자
* X가 Y를 함수적으로 결정한다.
* Y가 X에 함수적으로 종속되어 있다.


A가 다르면 B는 같거나 달라도 상관없지만, A가 같다면 B의 값은 항상 같아야한다.
* 자명한 함수 종속성 (Trivial Functional Dependency)
  + 릴레이션에 임의 속성은 하나의 후보키에 반드시 함수 종속 한다.
    - 후보키는 Attribute를 정확히 구분할 수 있는 최소의 속성집합이기 때문 
  + 후보키에 함수 종속이란 말은 슈퍼키에도 반드시 함수 종속이다. 후보키 ( 슈퍼키
  + 속성의 부분집합 x, y가 있을 때 XY->X, XY->Y는 항상 성립한다.
 
* 자명하지 않은 함수 종속성 (Non Trivial Functional Dependency)
  + 일반적으로 키 값이 정해지명 임의의 속성값을 구할 수 있다. X의 값이 같다면 Y값도 같다. 이런 상황을 만족시키지 않는 것이 **Non tirival** FD이다
  + Non Trivial FD 때문에 **정규화**를 진행해야한다.

### 부분 함수적 종속 (Partial Functional Dependency) 
릴레이션의 종속자가 PK가 아닌 다른 속성에 종속 되거나, PK가 Composite Key일 경우 PK를 구성하는 **일부 Attribute**에만 종속됨을 의미한다. **불완전 함수적 종속성**이라고도 한다.  
== X->Y 일 때, 후보키X의 진부분집합에도 Y가 함수 종속성이 성립하는 할 때 

### 완전 함수적 종속 (Full Functional Dependency)
종속자가 PK에만 종속한다. 즉, 결정자가 PK이다. PK가 Composite Key로 구성된 경우 구성하는 **모든 속성이 포함된 PK**의 부분집합에 종속되어 있음을 의미한다.

### 이행적 함수 종속(Transitive Functional Dependency)
릴레이션에서 X, Y, Z라는 3가지 Attribute가 있을 때 X->Y, Y->Z이란 종속 관계가 있을 경우 X->Z가 성립될 때 이행적 함수 종속이라고 한다.
<br></br>
## 정규화 (Normalization)
관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 과정.
* 타당한 이유가 있다면 무조건 높은 정규화까지 만족시킬 필요는 없다.
* 3NF, BCNㄹ, 4NF는 정규화에 주의해야한다.
정규화를 실시할 때 관계스키마는 Non-lossless join property가 필수 이며, Dependency preservation property는 권장 사항이다.

### 이점
* 불필요한 데이터 중복성을 최소화
* 이상현상(Anamolies) 방지
* 데이터 저장을 **논리적**으로 한다. -> 논리적? : 테이블 구성이 논리적이고, 직관적이여야 한다.

### 제 1 정규형 (1NF; First Normal Form)
릴레이션에 속한 모든 속성의 값이 **원자값(Atomic value)** 을 가져야 한다. nested relation 속성을 없애야한다.
* 원자값 : 컬럼의 값이 단 한 개 존재해야 해야하는 것을 의미한다.

* 아래 표에서 헐크는 취미가 두 개이므로 원자값이 지켜지지 않았다. nested한 속성이 존재.  
![image](https://user-images.githubusercontent.com/56042451/168461873-e707bef2-579a-4cb6-890c-6a7f1301ce54.png)
* 헐크의 취미값을 하나만 갖게 하여 제 1 정규형을 만족시켜야한다.  
![image](https://user-images.githubusercontent.com/56042451/168461968-3e96c2a5-38fb-4929-b653-01c48d0c3500.png)

### 제 2 정규형 (2NF; Second Normal Form)
제 1 정규형에 속하며, 기본키가 아닌 모든 속성(nonprime attribute)이 기본키에 완전 함수 종속이면 제 2 정규형이라 한다. == 제 1 정규형을 만족하는 릴레이션에서 부분(불완전) 함수 종속을 제거해야한다 -> 복합키가 존재하는 경우. 

* **2NF를 실시하는 선수조건**
  + 최소 2개 이상의 atrribute로 구성된 키여야 한다. == Composite Key
  + PK가 Composite Key인 진부분 집합의 Attribute가 다른  Nonprime attribute를 종속 시키는 경우 == partial functional dependency
    - 예시) AB -> C 이며, A -> D 인 경우 2NF를 만족시키지 못하므로 테이블을 분해해야한다.

* **부분 함수 종속성이 있는 예**  
![image](https://user-images.githubusercontent.com/56042451/168462189-b28656de-285e-4ce2-a1fd-9087aae1ce0b.png)  
(NAME, HOBBY) -> AGE, NAME -> AGE == partial functional dependency  
NAME을 FK로 하여 AGE를 다른 테이블로 쪼개준다.

  * TABLE_1  
![image](https://user-images.githubusercontent.com/56042451/168467053-be8a4d3d-7229-40f7-86f2-a8307b056541.png)


  * TABLE_2  
![image](https://user-images.githubusercontent.com/56042451/168462373-267ebae3-8f77-421d-abd0-f8c9bd75a650.png)

#### 문제점
하지만 제 2 정규형에서도 완벽하게 이상현상을 제거하기는 어렵다.


### 제 3 정규형 (3NF; Third Normal Form)
제 2 정규형을 만족시키며, 기본키가 아닌 모든 속성(nomprime atrribute)이 이행적(transitive) 함수 종속이 되지 않으면 제 3 정규형이라 한다. 즉, 3차 정규형은 **기본키**를 제외한 속성들 간 종속이 없어야 한다.
* **이행적 : X->Y, Y->Z 일 때, X->Z가 성립한다.**

* **제 3 정규형을 실시하는 선수조건**
  + 2개 이상의 nonprime attribute가 있어야한다.
  + PK가 종속시키는 종속자가 다른 non-key attribute를 종속시키는 경우, A(pk) -> B(non-pk),   B(non-pk) -> C(non-pk)
  + B와 C는 무조건 non-key attribute여야 한다. 

* 이행적 문제가 있는 예  
![image](https://user-images.githubusercontent.com/56042451/168462958-23a771c3-4aa9-430c-8468-4755667f13ea.png)  
위의 테이블을 보면 PHONE열은 PRIMARY KEY인 ID열이 아닌 GROUP열에서도 완전 함수 종속이 일어나게 된다. ID->GROUP, GROUP-> PHONE 이를 이행적 함수 종속이라고 한다.
    + **Update Anomaly** : 다수의 캐릭터가 추가 된다고 가정 시, 특정 그룹의 PHONE 번호가 변경된다고 할 시 모든 캐릭터의 해당 그룹의 PHONE 번호를 변경해야한다
    + **Insert Anomaly** : 현재 GROUP에 소속한 캐릭터가 없는 새로운 GROUP을 추가한다고 할 시, PRIMAY KEY가 NULL 값인 그룹이 추가되어야 하기 때문에 삽입이상이 발생하게 된다.
    + **Deletionn Anomaly** : ID가 5 또는 6인 그루트와, 블랙팬서를 삭제할 시 GORUP이 없어지는 삭제이상현상이 발생하게된다.
* 이행적 문제를 해결 방안 -> PK,와 FK의 관계로 쪼갠다.0
* TBALE_1  
![image](https://user-images.githubusercontent.com/56042451/168463053-02e240bd-b81c-48ff-a001-53e793ae0812.png)
* TABLE_2  
![image](https://user-images.githubusercontent.com/56042451/168463083-eb59fdb1-4a8c-4f98-8666-1f347fe418b5.png)

### BFNC (Boyce and Codd Normal Form)
**모든 결정자**가 후보키가 되면 무조건 BCNF를 만족시킨다.
후보키가 1개 밖에 없는 경우 즉 후보키가 주키가 되고 제 3 정규형을 만족시키면 항상 BCNF 만족시킨다. 하지만 후보키가 여러개인 경우 이상 현상이 발생하기도 한다. 이를 해결하기 위해 BCNF가 고안되었다. 제 3 정규형보다 더 엄격한 제약조건을 갖기 때문에 **Strong 3NF**이라고도 한다.


## 트랜잭션(Transaction)
데이터베이스의 상태를 변경(retrieval and update)시키는 하나의 논리적 기능 수행위한 작업의 단위(unit of work)를 뜻한다.
* 데이터 상태 변경? : SQL을 이용하여 데이터베이스에 접근하는 것을 의미한다.
  + INSERT
  + DELETE
  + UPDATE
  + SELECT
* Unit of work : 작업의 단위는 질의어 명령문 그대로가 작업의 단위가 아니다. 이것은 프로그래머가 어떻게 설정하느냐에 따라 작업의 단위가 달라질수있다.
  + 돈을 입금하고 입금한 내역이 화면에 출력되어야한다라고 가정하면 입금은 INSERT작업, 출력은 SELECT작업 총 2개의 SQL 질의어가 한 작업의 단위로 처리되는 것이다. 이 두 질의어가 한 트랜젝션(Transaction)이 되는 것이다.
  + 작업의 단위, 즉 트랜잭션을 어떻게 설계를 하느냐에 따라 데이터베이스를 다루는 것에 많은 이점이 있다.

### 트랜잭션 처리 과정
  1. START TRANSACTION
  2. 보조기억장치(HDD, SSD...)로부터 데이터 값을 main memory의 버퍼에 적제한다.
  3. 데이터의 상태 변경을 수행한다.
  4. main memory의 버퍼에서 보조기억장치에 기록한다.
  5. commit

트랜잭션의 과정은 보조기억장치로부터 메인메모리에 적제 이후 버퍼에서 보조기억장치에 기록하는 것까지 트랙잭션 과정이다. 하지만 대부분의 DBMS는 조금 다른 방법으로 작동한다. 
* 방법1 : 보조기억장치로부터 main memory에 적제 -> 데이터 변경 -> 부분완료(partially committed) -> 보조기억장치에 기록 -> 완료(commit)
  + 위에서 설명한 방법이며, 대부분은 DBMS에서 이러한 시스템으로 작동한다. 이유는 보조기억장치에 접근 및 기록하는 것은 시간이 걸리는 작업이기 때문에 부분 완료로 임시로 트랜잭션이 완료되었음을 관리자에게 알려주고 관리자가 이후 보조기억장치에 저장하게 된다.
* 방법2 : 보조기억장치로부터 main memory에 적제 -> 데이터 변경 -> 보조장치에 기록 - 완료(commit)
  + 실질적인 모든 트랜잭션의 과정이다. 

### 특징(ACID)
* **원자성(Atomicity)** : 트랜젝션은 모두 반영되던가 전혀 반영되지 않아야 한다는 것이다. (all or nothing), 트랜잭션 수행 시 어떤 명령 하나라도 완벽히 수행되지 않는다면 트랜젝션은 취소가 된다.
* **일관성(Consistency)** : 트랜젝션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것이다.
* **독립성(Isolation)** : 둘 이상의 트랜잭션이 동시에 수행되며 같은 데이터에 접근할 시 한 트랜잭션만 수행되어야 한다. 
* **지속성(Durability)** : 트랜젝션이 성공했을 경우 결과는 시스템이 고장나더라도 영구적 반영되어야 한다는 것이다.

### DBMS에서 ACID를 유지하는 방법
* Atomicity : 원자성을 유지하기 트랜잭션 과정에서 장애가 발생하면 회복(복구) 관리자 프로그램을 작동시킨다. ROLLBACK기능
* Consistancy : 일관성을 유지하기 위해 2개 이상 트랜잭션이 한 데이터를 동시에 처리하지 못하도록 **동시성(Concurrency)제어 알고리즘**과, **무결성 제약조건**으로 잘못된 데이터가 저장되지 못하도록 한다.
* Isolation : 고립성을 유지하기위해 동시성 제어 알고리즘을 작동한다.
* Durability : 지속성을 유지하기 위해 회복 관리자 프로그램을 이용한다.
![image](https://user-images.githubusercontent.com/56042451/168836838-326c9d42-b4a4-4c82-868d-f06cd44b28e9.png)

### TCL(Transaction Control Language)
* COMMIT : 트랜잭션이 성공적으로 끝났고 데이터베이스가 다시 consistency한 상태에 있을 때 해당 트랜젝션이 연산이 완료되었음을 트랜잭션 관리자에게 알려주는 연산
* ROLLBACK : 트랜젝션이 비정상 종료되어 데이터베이스의 consistency를 지키지 못했을 때, Atomicity를 구현하기 위해 해당 트랜젝션의 모든 연산을 취소 하는 것이다. rollback시 해당 트랜젝션을 재시작하거나 폐기한다.
* SAVEPOINT : 트랜잭션내에서 세부적인 작업을 또 하나의 단위로 나누어 특정 단위가 실행된 후 저장지점을 만들어 차후 트랜잭션 실행 중 이상이 생기더라도 새로 트랜잭션을 실시하는 것이 아닌 SAVEPOINT부터 시작하거나 ROLLBACK 시 특정 지점으로 복구 가능하게 하는 것이다. 

### 상태
* 트랜젝션
  + 완료(Active) : 트랜젝션이 실행중인 상태
    - 부분완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행되었지만 commit 연산이 실행되지 직전의 상태
        - 완료(committed) : 트랜젝션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태
    - 실패(Failed) : 트랜젝션 실행중 오류가 발생한 상태
        - 철회(Aborted) : 트랜잭션이 비정상 종료되어 rollback연산을 수행한 상태

### MYSQL
각 DBMS별 데이터를 저장하는 방식이 있는데 이는 DBMS에서 설정된 저장엔진에 의해 데이터가 저장된다. 저장엔진은 모두 트랜잭션을 지원하지는 않는다. 과거 MYISAM 저장엔진은 트랜젝션을 지원하지 않고 있다. 현재는 대부분 MYSQL은 INNODB를 사용하기 때문에 트랜젝션을 지원한다.

대부분 DBMS에서 트랜젝션을 명시적으로 사용하지 않으면 자동으로 데이터베이스를 변경해버리기 때문에 프로그래머가 DML연산 수행 시 트랜젝션을 명시적으로 지정하여 데이터 변경을 조심스레 처리한다. 

START TRANSACTION으로 트랜잭션을 실시할 시 해당 테이블 또는 데이터에 락이 지정되어 다른 사용자는 접근이 불가능하다.  
#### USER1
```sql
#USER1

START TRANSACTION; #트랜젝션 시작
# 특정 열 값 업데이트 실시
UPDATE Doctors
SET doc_name = '안성기'
WHERE doc_name like '안기욱';

# 변경데이터 확인
SELECT * FROM Doctors WHERE doc_name like '안기욱';

COMMIT; 또는 ROLLBACK; #commit시 데이터 변경 Rollback시 원본 데이터 복구
```
#### USER2
USER1에서 트랜잭션을 시작하고 COMMIT 또는 ROLLBACK을 수행되기 전 USER2에서 해당 테이블을 접근하여 변경하는 경우 USER1의 트랜젝션에서 걸어둔 **LOCK** 때문에 대기 상태에 있게된다. 조회(SELECT) 구문은 데이터 변경을 일으키지 않기 때문에 변경가능하다. 단, USER1에서 UPDATE로 변경된 데이터가 아닌 변경이 되지 않는 데이터가 조회된다. 이 이유는 TRANSACTION이 INSERT하는 곳이 DBMS내가 아닌 메모리상에서 처리하기 때문이다.
```sql
#USER2
#USER1의 트랜젝션 수행 완료전에는 대기상태에 머무름
UPDATE Doctors
SET doc_name = '김변경'
WHERE doc_name like '유재석';
```
#### SAVEPOINT
트랜잭션 내부에서 사용자가 지정할 수 있는 세부 작업단위로 SAVEPOINT는 트랜잭션 작업 중 임시로 저장 지점을 만들어 차후 오류가 생기더라도 처음부터 트랜잭션을 다시 시작하는 것이 아닌 SAVEPOINT가 된 지점부터 실행 가능하다.
![image](https://user-images.githubusercontent.com/56042451/168941458-dc4a8cf5-7f37-46ac-9d88-6967f1b3ebee.png)
SAVEPOINT SP1으로 ROLLBACK 될경우 SP2는 삭제된다.

### AUTO COMMIT 기능
위에서 대부분의 DBMS는 자동으로 데이터 변경을 처리한다고 하였다. 자동으로 처리되는 이유는 AUTO COMMIT 기능이 활성화가 되어있기 때문이다. Mysql에서는 AUTO COMMIT 기능을 OFF설정하면 데이터를 수정하여도 변경되지 않고 사용자가 직접 COMMIT 연산을 수행해야 데이터베이스에 반영이 된다.
```sql
SET AUTOCOMMIT = 0; #AUTO COMMIT OFF
SET AUTOCOMMIT = 1; #AUTO COMMIT ON

SELECT @@AUTOCOMMIT # AUTO COMMIT 설정 여부가 출력
```

**SET AUTOCOMMIT = 1**  
![image](https://user-images.githubusercontent.com/56042451/168762620-0669d89c-b393-4fc9-b1d4-7f97532dfea0.png)

## 동시성 제어(Concurrency control)
여러 트랜잭션이 동시에 실행될 때, 데이터의 일관성을 해치지 않도록 테이터의 접근을 제어하는 DBMS의 기능이다. == 병행성 제어

### 시나리오(두개의 트랜잭션)
* 트랜잭션 두 개가 동시에 데이터를 '읽기'로 접근하는 경우 
  + 읽기만 하면 데이터의 변경이 일어나지 않기 때문에 일관성을 해치지 않는다. 
* 트랜잭션 한 개는 읽고 한개는 쓰기가 일어날 때
  + 한 트랜잭션이 데이터를 쓰고 있을 때 다른 트랜잭션이 읽기를 시도하면 두 트랜잭션이 조회했을 때 반환되는 결과값이 다르다.
* 두 트랜잭션이 동시에 쓸때
  + 데이터가 꼬일 수 있어서 **매우 조심** 해야한다.

### 갱신 손실 문제(Lost update)
두 개이상의 트랜잭션이 동시에 한 데이터를 갱신할 때 발생한다. lost update문제는 무조건 발생해서는 안된다.

#### 1. 문제 발생 시나리오
둘 다 돈을 인출하는 작업 시 현재 금액을 조회하고 인출해야할 것이다. 조회를 위해 동시에 계좌에 접근하면 둘다 같은 값을 갖게 되고 둘다 인출하고 인출된 금액만큼 제외하고 다시 데이터를 저장 시 최종적으로 마지막으로 저장한 데이터가 DB에 저장되게 된다. 이러면 데이터의 일관성이 깨지게 된다.

#### 2. 해결방안
* 2-1. 순서대로 진행
  + 둘 이상의 작업을 순서대로 진행하는 것이다. T1 -> T2 또는 T2-> T1 하지만 이런방법은 빠른 데이터 처리가 되지 않기 때문에 좋지 못하다
* 2-2. 락
  + 데이터의 특정 트랜잭션이 접근 중인지에 대해 알수 있는 규칙 같은 것.


## 락
락은 현재 데이터가 읽거나 수정 중일때 현재 데이터를 잠금하는 장치이다.  
트랜잭션1이 특정 데이터에 락을 걸고 작업한다면 다른 트랜잭션은 접근 할 수 없다. 트랜잭션1이 Unlock을 하면 다른 트랜잭션이 진행가능하다. 하지만 트랜잭션은 사용자 시간에 응답을 주기 때문에 가능한 최소화 해야한다.

### 락의 유형
#### 1. 공유락 (LS, shared lock)
데이터를 읽을 때 사용하는 락

#### 2. 배타락 (LX, exclusive lock)
읽기/쓰기를 할 때 사용하는 락

#### 3. 사용 규칙
1) 데이터에 락이 걸려있지 않으면 락을 걸 수 있다.
2) 데이터를 일긱만 할 경우 공유락을 요청, 읽거나 쓰기 할 때는 배타락을 요청
3) 트랜잭션이 데이터에 공유락을 걸어두면 다른 공유락은 허용하지만 배타락은 혀용하지 않음
4) 트랜잭션이 데이터에 배타락을 걸어두면 다른 모둔 락은 허용하지 않음
5) 트랜잭션이 데이터를 접근할 때 락이 걸려있으면 대기 상태가 된다.

### 2단계 락킹
락을 걸고 실질적으로 해제하는 시점 짧은 순간 해지 상태가 되면서 다른 트랜잭션에게 중간 결과를 보일 수 있다. 이를 방지하기 위해 2단계 락킹 기법을 사용한다.

* 확장단계(Growing phase, Expanding phase)
  + 트랜잭션이 필요한 락을 획득하는 단계, 이미 획득한 락을 해제하지 않는다.
* 수축단계(Shrinking phase)
  + 트랜잭션이 락을 해제하는 단계, 새로운 락을 획득하지 않는다.

#### 데드락(Deadlock)
2단계 락킹 기법을 사용하면 데이터 일관성은 유지할 수 잇으나 두 개이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기상태에 빠질 가능성이 있다.
* 해결방안
  + 데드락이 되는 트랜잭션 하나를 강제 작업 중지시킨다. 중지하는 트랜잭션은 데이터를 rollback해야한다..

## 트랜잭션 고립 수준
락과 순서처리 방법은 두 트랜잭션이 동시에 쓰기 작업을 위한 방법이었다.  
두 트랜잭션이 각각 읽기, 쓰기 작업을 한다면 락 또는 순서처리 방법은 매우 엄격한 방법일 것이다. 

### 동시 실행 문제
두 트랜잭션이 각각 읽기, 쓰기 작업을 한다면 읽는 트랜잭션에서는 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 같은 문제 등이 발생 할 수 있다.
* 오손읽기(dirty read)
  + 데이터는 쓰는 트랜잭션이 작업하는 과정 도중 읽기 트랜잭션이 중간 업데이트 된 데이터를 읽게 된다. 만약 쓰는 트랜잭션이 rollback하게 되면 읽기 트랜잭션이 읽었던 데이터는 실질적으로 무효화 되었지만 이미 데이터를 읽어버려 잘못된 결과를 도출한다.
* 반복 불가능 읽기(non-repeatable read)
  + 트랜잭션 하나가 데이터를 이미 읽고 다른 트랜잭션이 데이터를 UPDATE하여 이미 데이터를 가져온 트랜잭션의 데이터는 이전 데이터가 되게 되어 다시 조회를 하였을 경우 이전 데이터가 조회되지 않는 현상
* 유령데이터 읽기(phantom read)
  + 트랜잭션 하나가 데이터를 읽고 다른 트랜잭션이 데이터를 INSERT한 경우 이미 데이터를 읽었던 트랜잭션이 다시 조회를 했을 경우 새로운 데이터가 추가 되어있는 경우 
  
### 해결방안
동시 실행 문제도 락을 사용하면 해결되지만 DBMS에서는 조금 느슨한 방법으로 동시 실행 문제를 해결한다. 


## 데이터베이스 회복(Recovery)
데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS기능

### 장애의 유형
* 트랜잭션장애
  + 논리적 오류
    - 트랜잭션 내부적 오류로 트랙잭션을 완료할 수 없는 경우
  + 물리적 오류
    - Deadlock 등 오류조건으로 활성 트랜잭션을 강제 종료하는 경우
* 시스템 장애
  - 전원, 하드웨어, 소프트웨어 등의 고장
* 디스크 장애
  - 디스크 공간이 일부 또는 전체가 붕괴 되는 경우
* 사용자 장애
  + 사용자의 데이터베이스시스템에 대한 이해부족으로 인한 경우
  + 사용자의 실수
* 재난

### 트랜잭션과 회복
* 모든 회복은 트랜잭션 단위로 회복한다. 
* START TRANSACTION을 선언하지 않았다고 해서 트랜잭션으로 처리가 안되는 것이 아니다. 모든 질의문은 하나의 트랜잭션으로 실행된다. 다만 MYSQL의 경우 AUTOCOMMIT 때문에 트랜잭션으로 처리하는 것 처럼 보이지 않아서 착각하는 것이다.
* 트랜잭션의 Atomicity, durability를 보장하여 데이터베이스를 보호한다.
* 트랜잭션 실행 시 **로그파일**에 선기록 후 보조기억장치에 저장한다.

### 회복을 위한 기본 연산
* 재실행(Redo)
  + 데이터베이스 내용 자체가 손상된 경우 최근 복제본을 적재시켜 복재본 이후에 일어난 변경만을 로그를 이용하여 재실행하여 데이터를 복원한다.
* 취소(Undo)
  + 데이터베이스 내용 자체는 손상되지 않았지만 변경 중이거나 변경된 내용에 대한 신뢰성을 잃어버린경우 로그를 이용하여 모든 변경을 취소하여 데이터를 복원한다.

### 로그파일 이용한 회복
* 지연갱신 회복기법 : Redo만 수행
  + 지연갱신은 트랜잭션이 끝난 후(부분 완료) 후 최종 완료는 DBMS에서 버퍼에서 하드디스크에 기록하는 것이다
  + 지연갱신을 이용할 경우 트랜잭션의 변경된 내용을 전부 로그에 기록하고 나중에 DBMS가 직접 변경된 파일을 기록하는 것이기 때문에 로그에 남아있는 트랜잭션 로그는 무조건 정상적으로 실행 된 것이고 이 내용이 DBMS에 반영됬는지는 불명확하기 때문에 Redo만 수행하면 된다. 만약 트랜잭션이 실행도중에 장애가 발생하면 로그에서 기록을 지운다.
* 즉시갱신 회복기법 : Redo, Undo 수행
  + 즉시갱신은 트랜잭션이 로그 데이터를 변경하면서 하드디스크에 데이터도 같이 변경하는 것이다.
  + 즉시갱신을 이용할 경우 트랜잭션의 원자성을 보장하지는 않는다. 그래서 장애가 발생하였을 때 Redo, Undo 모두 수행하여야 한다.

### 검사시점 회복(CheckPoint)
#### Why?
단순히 로그파일만 이용해서 회복을 진행할 경우 로그파일 전체를 검사해야한다. 이것은 시간이 매우 오래 걸리는 작업이며 또한 이미 완료된 트랜잭션을 redo가 필요없는 트랜잭션도 다시 redo하게 되어 시간, 자원이 낭비된다. 이런 낭비를 방지하기 위한 방법으로 **checkpoint**을 이용한다. DBMS가 checkpoint를 실시할 시 주기억장치 내 버퍼의 모든 내용이 보조기억장치에 강제로 기록된다. 체크포인트 시점에서는 주메모리 내 버퍼와 보조메모리상의 데이터가 일치하게 된다.  
* checkpoint를 선언하면 주기억장치의 로그 레코드를 보조기억장치의 로그 파일에 저장한다.
* 버퍼에 있던 변경된 내용은 보조기억장치의 데이터베이스에 저장한다.
* 체크포인트를 로그 파일에 표시한다.

#### Immediate update checkpoint recovery
즉시 갱신은 로그데이터를 변경하면서 보조기억장치의 데이터도 같이 변경하는 것이므로 undo, redo 작업 둘 다 필요하다
* 체크포인트 이전의 commit 기록이 있는 경우
  + 회복할 필요가 없다. 이미 checkpoint 이전의 기록은 모두 데이터베이스에 반영되었다.
* 체크포인트 이후 commit 기록이 있는경우
  + REDO를 진행한다. 트랜잭션의 모든 변경이 처리 되지 않았기 때문에 일부는 데이터베이스에 반영이 않되었을 것이다.
* 체크포인트 이후 COMMIT 기록이 없는 경우, 즉 트랜잭션 처리 중에 에러가 발생한 경우
  + UNDO를 진행한다. 일부 데이터가 반영이 되어 durability를 지키지 못한다.

### deferred update checkpoint recovery
지연 갱신은 로그 데이터를 변경 후 버퍼에서 데이터베이스를 DBMS가 변경 하는 것이므로 REDO 작업만 필요하다.
* 체크포인트 이전의 commit 기록이 있는 경우
  + 회복할 필요가 없다. 이미 checkpoint 이전의 기록은 모두 데이터베이스에 반영되었다.
* 체크포인트 이후 commit 기록이 있는경우
  + REDO를 진행한다. 트랜잭션의 모든 변경이 처리 되지 않았기 때문에 일부는 데이터베이스에 반영이 않되었을 것이다.
* 체크포인트 이후 COMMIT 기록이 없는 경우, 즉 트랜잭션 처리 중에 에러가 발생한 경우
  + 아무 작업을 할 필요가 없다. 로그 기록은 남아 있지만 지연 갱신이기 때문에 데이터베이스는 갱신이 안되었기 때문이다.

### 미디어(디스크) 회복
미디어 회복의 기본 원리는 데이터베이스의 내용을 주기적으로 다른장치에 dump시키는 방법이다. 장애가 발생하면 최근 dump된 파일을 복구하고 로그 파일을 참조하여 dump 이후 작업을 redo한다. undo는 사용하지 않는다.



## DML
### UPDATE
UPDATE문에서 가장 주의를 요하는 것이 조건절을 쓰지 않고 실행하는 것이다. 조건을 사용하지 않고 데이터를 변경한다면 전체 데이터가 변경 되게 된다.
* Tip
  + UPDATE를 실시하기 전 SELECT 문으로 조회 후 사용한다
  + UPDATE는 트랜젝션 안에서 처리한다. commit 연산을 수행하기 전 한 번더 체크하므로써 안전하게 작업할 수 있다.
#### 1
# MYSQL
## JOIN 
두 개이상의 테이블을 묶어서 하나의 결과 테이블로 만들어 내는 것이다.

### 1. INNER JOIN
보통 JOIN이라고 하는 것은 INNER JOIN을 의미한다. 두 테이블에서 교집합된 부분만 결합한다.
```mysql
SELECT * 
FROM SALARIES S 
	INNER JOIN employees E 
	ON S.EMP_NO = E.EMP_NO
WHERE S.from_date >= date('1986-06-26');
```
#### 1-1 INNER JOIN 속도
보통 INNER JOIN은 OUTER JOIN 보다 속도가 빠르다. 이너 조인은 보통 HASH MATCH을 사용하기 때문에 O(n)의 시간 복잡도를 갖고, 아우터 조인은 NESTED LOOP를 사용하기 때문에 O(n^2) 시간 복잡도를 갖는다. 하지만 무조건 빠른 것은 아니다. 보통 이너조인에서 조건 값이 INDEX가 주로 설정되어 있는 경우가 많기 때문에 아우터 조인보다 보통 빠르다는 것이다.

## 시간함수
### YEAR('DATE')
해당 DATE의 '년도'를 반환한다.





