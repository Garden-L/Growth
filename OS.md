# OS

## 빌드과정
빌드란 작성한 프로그램을 기계어로 번역해서 실행파일을 만들어내는 과정이다.

### 1. 소스코드 작성
C/C++로 작성 한다.
<img width="303" alt="image" src="https://user-images.githubusercontent.com/56042451/193445367-30c3be4c-928f-48c2-9d4c-f8f3d0ae3cdf.png">

### 2. Proprocessing (전처리)
전처리란 컴파일 전 코드를 적절한 상태로 준비 및 처리하는 일이다. 헤더파일 불러오기, define문 치환, 주석 제거 등을 처리한다. 전처리는 전처리기가 처리하게 되고 #으로 시작하는 구문 + 주석을 처리한다고 생각하면 된다. cpp 명령으로 전처리를 실행할 수 있다. 전처리를 실행 후에는 .i 파일이 생성되게 된다.
<img width="682" alt="image" src="https://user-images.githubusercontent.com/56042451/193445422-f1506a21-fcd1-4a40-9264-173bc2dca7f2.png">
```c
$ cpp test.c > test.i
또는
$ gcc -E test.c > test.i
```

#### 자세한 것은 https://www.ibm.com/docs/ko/aix/7.2?topic=c-cpp-command 


### 3. compile (컴파일)
전처리된 파일을 컴파일러가 현재 프로세서에 맞는 어셈블리 코드로 번역해준다. 전처리된 파일(.i)을 어셈블리 파일(.s)로 번역한다.

```c
$ gcc -S test.i
```
![image](https://user-images.githubusercontent.com/56042451/193445716-da16208e-e28a-4381-a7f1-3230425c2e0d.png)


### 4. Assemble
컴파일된 파일을 어셈블러가 Machine Code(이진수)로 번역하여 실제 기계가 읽을 수 있게 한다. 어셈블리파일(.s)를 목적파일(.o)파일로 번역한다. 

```c
$ as -o test.o test.s
```
<img width="703" alt="image" src="https://user-images.githubusercontent.com/56042451/193446080-3d0a3cf2-4465-4c01-b861-1de4456d50ec.png">


### 5. Linkng
생성된 목적파일들을 연결하는 작업이다. 여러 작업들을 분할했다면 이 과정에서 관련있는 서로의 파일들이 엮이게 된다. 또한 정적라이브러리도 여기서 합쳐지게 된다. 이 과정을 마무리로 실행파일(.out, .exe ...)가 생기게된다.

```c
$ gcc -o a.out test.o
```

## Process comunication
프로세스는 시스템내에서 독립적으로 실행되기도 하지만, 서로 데이터를 주고받으며 협업하기도 한다. 데이터를 주고받을 때는 프로세스끼리 통신을 해야한다. 또한 프로세스 내부에서 스레드끼리 통신이 가능하고, 소켓을 이용하여 각 호스트의 프로세스끼리도 통신이 가능하다.

### 1. 통신종류
* 프로세스 내 통신
  + 하나의 프로세스에서 두 개 이상의 스레드가 존재하는 경우 프로세스 내부에서 스레드 끼리 데이터를 주고받는 경우.
    - 전역변수 또는 파일 사용
* 프로세스 간 통신
  + 같은 시스템 내에서 두 개 이상의 프로세스 끼리 통신하는 경우
    - 메모리를 사용 (메인메모리: shared memory, 보조메모리: 파일, pipe(내부적으로파일))
* 네트워크를 이용한 통신
  + 여러 컴퓨터 간 네트워크로 연결되어 있는 경우
    - 소켓 사용, 원격 프로시져 호출(RPC)

프로세스 간 통신(Inter Process Comunication)이 스레드를 이용한 프로세스 내 통신 보다 어려운 이유?
스레드는 서로 메모리와 자원을 공유하기 때문에 같은 변수에 접근이 가능하다. 하지만 프로세스는 서로 다른 메모리 공간을 사용하기 때문에 별도의 공간을 만들어서 데이터 통신을 해야하기 때문에 프로세스 간 통신이 어렵다.

### 2. 통신 방향의 분류
통신 장치들은 데이터가 전송되는 방향에 따라 각기 불리는 이름이 다르다.

#### 2-1. 양방향 통신(Duplex communication)
양방향 통신은 동시에 양쪽 방향으로 전송할 수 있는 구조이다. 양방향을 구현하기 위해서는 변수가 두 개 있어야 가능하다. 1개만 사용하면 동시에 보낼 시 빨리온 데이터는 늦게온 데이터에 덮혀 쓰여지기 때문이다.

#### 2-2. 단방향 통신 (simplex communication)
단방향 통신은 한쪽 방향으로만 데이터를 전송할 수 있는 구조. 한쪽은 데이터를 무조건 보내고 한 쪽은 데이터를 무조건 받기만 한다.

#### 2-3. 반양방향 통신 (half-duplex communication)
반양방향 통신은 양쪽 방향으로 데이터 전송이 가능하지만, 동시 전송이 불가능한 형대이다. 한쪽에서 데이터를 보내고 있다면 한쪽에서는 데이터 전송 행위가 불가능 하다.

## Process
### 1. 개념
process란 메모리에서 현재 실행 중인 프로그램을 의미한다. 즉, 파일 형태의 프로그램이 실행되어 메모리 상에 적재되어 실행되면 프로세스가 되는 것이다. 리눅스에서는 프로세스보다는 task라는 말로 쓰인다.

### 2. 프로세스의 관리
프로세스 단위로 os에서는 스케줄링(프로세스 순서를 결정하는 행위)을 하거나 자원을 할당한다. 프로세스를 관리하기 위해서는 프로세스를 하나의 자료단위로 표현해야한다. 리눅스에서는 프로세스를 자료구조료 표현한 객체를 task descriptor라고 부르고, 실제 리눅스 코드를 보면 task_struct 구조체로 표현되어있다. task_struct에는 프로세스 단위로 관리해야할 여러가지(메모리 리소스, 프로세스 이름, 프로세스 ID ...)가 저장되어 있다. 운영체제에서는 일반적인 용어로 task_struct를 PCB(Process Control Block)이라 부른다

#### Systemmd
init 프로세스에서 이름이 변경된 프로세스로 유저 공간에서 생성된 프로세스의 부모 프로세스 역할을 수행한다.

## 명령어

### echo

#### 1. 설명
인자로 전달된 text/string을 표시하기 위한 명령어. 대부부 shellscript나 batch file에서 사용한다.
```bash
echo [option] [string]
```

### 2. 옵션
#### -e : 백슬래쉬의 해석을 가능하게 하는 옵션

1. \n
2. \r

## 부트로더
### 부트로더란?
운영체제는 자신이 직접 실행될 수 없다. 기본적으로 프로그램이 실행되기 위해서는 주메모에 적재되어야 한다. CPU는 이차메모리와 직접 통신하지 않고 주메모리와 통신하기 때문이다. 프로그램은 운영체제가 메모리에 적하는데 운영체제는 누가 적제하는가? 바로 부트로더란 소형 프로그램이 운영체제를 메모리에 적재하여 운영체제를 실행하게 한다. 정확히 말하면 운영체제의 커널 소스를 메모리에 적재한다.

### 운영체제 메모리 적재과정
컴퓨터에 전원이 들어오면 메인보드에 장착되어 있는 ROM이라는 비휘발성 메모리에 있는 BIOS라는 소프트웨어가 작동한다. 바이오스는 기본적인 시스템에 모든 장치를 초기화하고 운영체제를 적재하는 프로그램을 메모리에 적재하는 일을 한다. 즉 모든 프로그램에 시발점은 바이오스이다.  
바이오스는 운영체제를 실행시킬 수 있는 소형 프로그램(부트로더)를 2차 메모리 장치에서 찾아 메모리에 적재한다. 그런다음 부트로더는 운영체제의 커널을 메모리에 적재하게 된다.  
![image](https://user-images.githubusercontent.com/56042451/200335183-4ea06449-70c2-4f63-9c21-7f8d48d9b232.png)

### 바이오스는 어떻게 부트로더의 위치를 찾나?
바이오스는 모든 연결된 2차메모리 장치를 확인한다. 0번 섹터의 데이터이 512바이트를 확인하고 512바이트의 마지막 데이터가 0xAA55로 끝난다면 부트로더라고 판단하고 메모리 0x07C00(물리주소)번지에 적재하게 된다. 만약 0xAA55로 끝나지 않으면 부트로더가 아닌 것이다. 부트로더가 적재되는 메모리 위치 0x07c0와 부트로더 판단 매직넘버 0xAA55 약속이므로 의미를 부여할 필요는 없다. 부트로더가 있는 디스크의 0번 섹터는 MBR(Master Boot Record)라고 부른다. 운영체제를 실행시키는 코드 외 파티션을 구분하는 코드가 있다. 실질적인 부트로더는 446바이트를 사용하고 64바이트는 파티션의 관한 코드 2바이트는 매직넘버(0xAA55)이다.  
<img width="767" alt="image" src="https://user-images.githubusercontent.com/56042451/200459692-b560f003-7a97-4548-8ffe-ff5e8b070815.png">  
실제 8086 프로세서의 물리 메모리에는 여러가지 공간이 예약되어서 사용되고 있다. 

### 다양한 부트로더
부트로더의 종류는 매우 다양하다. 리눅스에서는 기존 LINO(linux loader)에서 GRUB, GRUB2까지 다양한 부트로더로 진화되어왔다.

### 커널의 메모리 적재?
부트로더는 커널을 메모리에 적재한다고 했다. 그럼 커널 소스는 어디있는가? 부트로더가 첫번째 섹터, 커널 소스는 두번째 섹터에 올리면 간단하게 해결된다. 다시 차근차근 알아보면 바이오스가 디스크의 첫번째 섹터에서 부트로더를 메모리에 적재하고 부트로더가 올라간 메모리에서 실행을 시작하게 한다. 부트로더는 커널과 관련된 다양한 일처리후 커널을 메모리에 적재한후 커널이 실행될 수 있도록 설정을 해주면 커널이 동작하게 된다.
<p align="center"> <img width="628" alt="image" src="https://user-images.githubusercontent.com/56042451/200741580-31895e44-74fa-46b6-861e-dfb9fa8ef4af.png"></p>

## MBR


## 리얼모드
### 1. 개념
리얼 모드는 약간의 계산으로 논리주소를 바로 물리주소에 매핑하는 방법이다. Intel 80286 이전 8086, 8088 프로세서에서 사용되던 방식이다. 80286 이후 보호모드라는 개념이 생기면서 이 방법이 리얼모드라고 지칭되었다. 당시 프로세서는 16bits 명령어 사용과 최대 1MB(20bits) 메인메모리를 사용했다. MS-DOS 같은 운영체제 시스템은 리얼모드로만 동작했다. 당시 1MB는 상당히 큰 메모리였고 IBM에서는 사용자에게 640KB만을 사용할 수 있도록 제약했다. 나머지는 공간은 커널 코드를 위한 공간이다.
![image](https://user-images.githubusercontent.com/56042451/200291356-12bd3a7c-aae9-4a9e-9ef2-3c5e0f7d727c.png)  
![image](https://user-images.githubusercontent.com/56042451/200298834-df2eaa57-e464-41c5-b263-162ade08abd6.png)

### 2. 리얼모드의 문제점
첫 번째로 프로그램이 한번에 한 개만 동작한다는 것이다. 현재 시스템에서는 싱글 프로세서에서도 여러 프로그램이 동시에 작동한다. 이것은 메모리 분할 기법과 관련이 있지만 리얼모드에서는 메모리 분할 기법이 없다. 단, 직접 메모리에 프로그램의 명령어를 상주하게 하므로써 접근하여 실행한다. 두 번째는 다른 영역에 침법가능성이다. 현재 프로그램이 아무리 잘못만들어져도 OS의 코드나 다른 시스템 코드에 접근하지는 못한다. 접근하려면 시스템 콜을 호출해야한다. 하지만 리얼모드는 직접 물리 메모리에 접근이 가능하기 때문에 다른 시스템 코드를 잘못 수정하여 에러 발생가능성이 존재했다.

### 3. 물리주소로 매핑
리얼모드에서는 16bits를 프로세서를 사용한다고 했다. 하지만 16비트는 최대 2^16 크기의 메모리만 사용가능 한데 1MB이라는 것은 말이 되지 않는다. 이를 해결하기 위해 범용 레지스터를 이용하여 20비트 크기를 사용한다. 범용 레지스터의 4bits 크기를 이용한다. 물리 주소 매핑 방식은 세그먼트:오프셋 방식이다. 세그먼트를 왼쪽으로 4비트 만큼 옳기고 오프셋을 더하여 물리주소를 계산한다.

## 8086 processor Segmentation 
### 8086 프로세서의 세그먼테이션이란?
세그멘테이션이란 메모리를 가변크기로 분할하는 개념을 의미한다. 과거 8086 컴퓨터도 비록 메모리는 1메가바이트지만 세그먼트로 분할할해서 사용했다.  
![image](https://user-images.githubusercontent.com/56042451/200558286-2eec3e89-e384-49c3-a3cd-8f53d4f4c483.png)

### 8086 세그먼트의 크기?
8086의 최대 세그먼트의 크기는 64킬로바이트였다. 메모리 세그먼트를 담당하는 레지스터들이 16비트로였기 때문이다.

## 하드웨어 레벨에서 메모리 세그먼트
### 하드웨어 수준의 메모리 세그먼트란?
메모리를 각 세그먼트로 분할한 방법이 메모리 세그먼테이션 기법이다. 80286 프로세서의 발명으로 보호모드라는 개념이 생겼으며 이전 시스템에서는 리얼모드라는 이름으로 부트스트랩을 위한 모드가 되었다. 리얼모드에서 보호모드로 진입하기 위해서는 하드웨어 수준에서 지원하는 메모리 세그먼트와 관련된 레지스터들을 설정해야 보호모드로 진입할 수 있다.

### Segment Selector란?
세그먼트 셀렉터는는 세그먼트 레지스터를 의미한다. 리얼모드에서는 세그먼트 레지스터 보호모드에서는 세그먼트 셀렉터로 불린다. 셀렉터의 종류는 CS, DS, SS, ES, FS, GS 등이 있다. 보호모드에서 셀렉터는 디스크립터 테이블이라는 메모리 세그먼트의 집합의 주소를 가리키기 때문에 세그먼트 셀렉터라 부르는 것이다.
* Code segment register(CS) : 프로그램 명령을 포함하는 세그먼트를 포인팅하는 레지스터, 이진수로 구성된 실행파일이 코드 세그먼트로 올라가고 CS 레지스터는 이 세그먼트를 가리킨다. 그리고 cpu에서는 CS + IP(다음 실행될 주소, offet으로 사용) 계산하여 선형주소를 구해 물리주소에 있는 명령어를 실행한다.
* Stack segment register(SS) : 현재 프로그램 스택을 포함하는 세그먼트를 포인팅하는 레지스터
* Data segment register(DS) : 전역, 정적 데이터를 포함하는 세그먼트를 포인팅하는 레지스터
위에 설명하는 레지스터는 당연히 리얼모드에서의 레지스터의 역할이고 보호모드에서는 셀렉터가 세그먼트를 포인팅하는 것이아닌 세그먼트의 집합인 세그먼트 디스크립터 테이블의 주소를 가리키는 것이다.

#### 세그먼트 셀렉터 구조
<img width="453" alt="image" src="https://user-images.githubusercontent.com/56042451/200590791-d363fa02-f1b0-427e-8215-01e9d61ff826.png">  
* index : 세그먼트 디스크립터 테이블의 주소를 가리키는 공간
* TI(Table Indicator) : 세그먼트 디스크립터 테이블은 GDT(gloabl descriptor table), LDT(Local Descriptor table) 두 가지가 있는데 0으로 설정될 경우 GDT, 1로 설정될 경우 LDT를 index가 가리키는 것이다.
* PRL(Requestor Privilege Level) : 셀렉터가 가리키는 세그먼트의 권한이다. 0은 커널레벨, 3은 유저레벨이다.

### 세그먼트 디스크립터란?
각 메모리의 세그먼트는 8바이트의 세그먼트 디스크립터로 나타내어진다. 그리고 이 세그먼트 디스크립터는 GDT, LDT 둘 중하나에 속해있어야 한다. 보통 GDT는 1개만 존재하고 LDT는 여러개를 만들어 낼수 있다. GDT는 커널에서 LDT는 유저레벨에서 생성된다고 보면된다. GDT가 정의된 주소는 gdtr(GTD register)가 포인팅하고 있다. LDT레지스터는 존재하지 않는데 이유는 GDT의 세그먼트 디스크립터에서 LDT를 가리키는 디스크립터가 있기다. 즉 LDT는 GDT내에 속해 있다. * LDTR 레지스터가 존재하여 LDT를 따로 포인팅하고 있다는 좀더 알아봐야겠음

### 세그먼트 디스크립터 구조
![image](https://user-images.githubusercontent.com/56042451/200595373-26571d8f-05f3-42f1-bae6-c37fb8cecc75.png)

### 세그먼트 디스립터 종류
세그먼트 디스크립터는 다양한 종류가 있다. 코드 세그먼트 디스크립터, 데이터 세그먼트 디스크립터, 태스크 상태 디스크립터, LDT 디스크립터 등이 있다.
* code segment descriptor : 코드 세그먼트를 가리키는 세그먼트 디스크립터, GDT 또는 LDT내에 속할 수 있다. 
* data segment descriptor : 데이터 세그먼트를 가리키는 세그먼트 디스크립터. GDT 또는 LDT내에 속할 수 있다. 
* task state segment : 태스트 상태 세그먼트를 가리키는 세그먼트 디스크립터. 프로세서의 레지스터 내용을 저장하는 사용되는 세그먼트이다. GDT에만 속할 수 있다. Type 필드가 11 또는 9로 설정되어야 한다. 
* LDT decriptor : LDT를 포함하고 있는 세그먼트를 가리키는 세그먼트 디스크립터. GDT에만 속할 수 있다. type필드가 2로 설정되어야 한다. 

### 세그먼트 디스크립터 테이블
세그먼트 디스크립터를 모아논 공간이다. 배열 형식으로 나열되어 있고 배열 첫 번째 주소가 배열를 가리키는 것처럼 세그먼트 디스크립터 테이블의 첫주소가 GDTR 또는 LDTR에 저장되어있다.  
![image](https://user-images.githubusercontent.com/56042451/200601177-62d0fae9-495d-4bd2-bb79-a5fd87b9968c.png)

### GDT
GDT는 중요한 분할된 메모리의 정보들을 배열형태로 나열되어있는 것이다. GDT는 반드시 한개를 정의해야하고 모든 시스템과 태스크에 의해 사용된다. 그리고 중요한 것은 GDT내의 LDT를 가리키는 LDT 디스크립터가 있다는 것이다. 또한 첫 번째 디스크립터는 NULL descriptor이기 때문에 모두 0으로 설정되어야 한다. 널 디스크립터가 존재하는 이유는 사용되지 않는 데이터 세그먼트 셀렉터(레지스터, 모든 비트가 0)가 접근을 시도하는 것을 막기 위함이다.
GDTR은 선형 베이스 어드레스 부분과 16비트의 테이블의 제한 값이 담겨있다. 세그먼트 디스크립터가 8바이트이고 16비트로 제한값을 사용하므로 최대 2^13개 만큼 세그먼트 디스크립터를 포함할 수 있다. 그리고 세그먼트 실렉터에서 인덱스값이 13비트로 표현되는 이유도 여기있다.

### LDT
LDT는 각 태스크 마다 정의 될 수 도있고 모든 태스크들이 공유할 수도 있다. 

### 논리 주소가 선형주소로 변하는 과정
결국 지금까지 이 조랄을 한 이유는 논리주소를 선형주소로 변화시키기 위함이다. 선형주소는 페이징 기법을 적용한 시스템에서는 페이징과 관련된 주소로 변화시킴을 의미하고 페이징 기법을 사용하지 않는다면 물리주소 그대로를 의미할 것이다.   
세그먼트 셀렉터의 TI(table indicator)를 확인하고 GDT에서 찾을 것인지 LDT에서 찾을 것인지 결정하고, GDT에서 찾았다고 가정한다면 GDTR에 세그먼트 셀렉터의 인덱스에 X8만큼 한 후 주소를 더한다. 그러면 세그먼트 디스크립터를 얻을 수 잇다. 얻은 세그먼트 디스크립터에서 베이스 어드레스와 기타 정보들을 얻고 베이스 주소를 통해 가지고 있는 주소(논리주소)를 더하면 선형주소를 얻게된다.

#### 선형주소 주하는 과정
![image](https://user-images.githubusercontent.com/56042451/200607461-25c7d095-977e-4c67-ba4b-faa04c87d71e.png)


## 하드디스크
### 하드디스크란?
메모리는 휘발성으로 시스템의 전원이 꺼지면 저장되어있던 데이터가 모두 지워진다. 하지만 하드디스크와 같은 2차 메모리는 비휘발성으로 전원이 꺼져도 데이터가 삭제되지 않는다.

### 하드디스크 구조
하드디스크 구조는 플래터, 액추에이터 암, 헤드, 전원 커넥터, 데이터 커넥터, 스핀들 모터로 이루어져있다.
<img width="470" alt="image" src="https://user-images.githubusercontent.com/56042451/200753115-8e1da133-f75e-4fee-9376-029108df497b.png">
* 전원 커넥터 : 하드디스크에 전원을 공급하는 역할
* 데이터 커넥터 : 하드디스크와 다른 디바이스간 데이터를 전송해주는 역할
* 헤드 : 플래터에 기록된 데이터를 읽거나 플레터에 데이터를 쓰는 역할
* 액추에이터 암 : 데이터를 요청할 시 데이터가 있는 곳으로 헤드를 이동하는 역할
* 플래터 : 실제 데이터가 저장되어 있음
* 스핀들 모터 : 플래터를 회전하는 역할

### 플래터의 논리적 구조
데이터를 저장하기 위해 하드디스크는 데이터를 논리적으로 저장한다.
#### 트랙
운동장의 트랙과 같다. 플래터의 둘레를 하나의 트랙이라고 한다. 안쪽부터 순차적으로 트랙번호가 매겨진다. 안
<img width="179" alt="image" src="https://user-images.githubusercontent.com/56042451/200753804-87228ccc-598c-4ce6-9ce4-abec7a960162.png">
#### 섹터
트랙을 잘게 잘게 열 단위로 나눈 것이다. 
<img width="177" alt="image" src="https://user-images.githubusercontent.com/56042451/200754162-ce72b3d3-5ae2-4911-b011-5275bc7ab4e0.png">
#### 실린더
기본적으로 플래터 여러장이 하드디스크에 존재하는데 각 플래터에서 같은 위치의 트랙의 집합을 실린더라고 한다. 같은 파일이면 같은 실린더에 배치하면 효과적으로 데이터를 찾을 수 있다.
<img width="180" alt="image" src="https://user-images.githubusercontent.com/56042451/200754274-12c8f389-9083-4d36-9d52-5f7281e1a254.png">

### 하드디스크 용량 계산
#### CHS(Cylinder, Head, Sector)
한 섹터에 512바이트 크기의 데이터가 기록된다는 것을 기억하자! 하드디스크는 논리적으로 실린더, 트랙, 섹터로 나누어진다고 했는데 그럼 이들의 개수만 알면 하드디스크의 용량을 구할 수 있다. CHS에서 이상한 점은 헤더의 수를 곱하는 것이다. 플래터는 단면이 아닌 양면으로도 기록될 수 도 있다. 양면으로 기록되면 한 플래터의 위 아래로 두개의 헤더가 존재하게 된다. 이렇기 때문에 헤더의 수를 곱해야 정확히 용량을 게산할 수 있다.  
<img width="513" alt="image" src="https://user-images.githubusercontent.com/56042451/200756259-919bd7be-6c41-4c67-bda4-8353fe758bc0.png">  
트랙 당 섹터의 수가 63개, 실린더가 128개, 헤더가 8개 라면 CHS의 식으로 계산했을 때 하드디스크의 용량을 얼마일까? 또한 헤더가 8개라면 플래터는 몇개일까? 뒷 질문의 답부터 한쪽면만 기록할 수 있는 플래터라면 각 플래터당 1개씩 총 8개가 있을 것이고, 양면으로 기록되는 플래터라면 하나의 플래터 당 위아래로 헤더가 한개씩 총 4개의 플래터가 있을 것이다. 
```
// 용량계산
1. 섹터수(63) * 실린더수(128) -> 플래터 한개를 단면으로 기록했을 때 총 섹터의 개수
2. 섹터수(63) * 실린더수(128) * 512bytes -> 플래터 한개를 단면으로 기록했을 때 총 용량
3. 섹터수(63) * 실린더수(128) * 512bytes * 헤드(8) = 31.5MB -> 플래터가 양면인지 단면인지는 모르나 총 용량이 된다 
```
CHS는 현재 잘 사용되지는 않는다. 하드디스크의 기록방법의 변화와 기록밀도가 증가하여 CHS로는 정확한 수치를 구할 수 없다.



# Create OS
## 1. 부트로더 작성



