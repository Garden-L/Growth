# OS

## 빌드과정
빌드란 작성한 프로그램을 기계어로 번역해서 실행파일을 만들어내는 과정이다.

### 1. 소스코드 작성
C/C++로 작성 한다.
<img width="303" alt="image" src="https://user-images.githubusercontent.com/56042451/193445367-30c3be4c-928f-48c2-9d4c-f8f3d0ae3cdf.png">

### 2. Proprocessing (전처리)
전처리란 컴파일 전 코드를 적절한 상태로 준비 및 처리하는 일이다. 헤더파일 불러오기, define문 치환, 주석 제거 등을 처리한다. 전처리는 전처리기가 처리하게 되고 #으로 시작하는 구문 + 주석을 처리한다고 생각하면 된다. cpp 명령으로 전처리를 실행할 수 있다. 전처리를 실행 후에는 .i 파일이 생성되게 된다.
<img width="682" alt="image" src="https://user-images.githubusercontent.com/56042451/193445422-f1506a21-fcd1-4a40-9264-173bc2dca7f2.png">
```c
$ cpp test.c > test.i
또는
$ gcc -E test.c > test.i
```

#### 자세한 것은 https://www.ibm.com/docs/ko/aix/7.2?topic=c-cpp-command 


### 3. compile (컴파일)
전처리된 파일을 컴파일러가 현재 프로세서에 맞는 어셈블리 코드로 번역해준다. 전처리된 파일(.i)을 어셈블리 파일(.s)로 번역한다.

```c
$ gcc -S test.i
```
![image](https://user-images.githubusercontent.com/56042451/193445716-da16208e-e28a-4381-a7f1-3230425c2e0d.png)


### 4. Assemble
컴파일된 파일을 어셈블러가 Machine Code(이진수)로 번역하여 실제 기계가 읽을 수 있게 한다. 어셈블리파일(.s)를 목적파일(.o)파일로 번역한다. 

```c
$ as -o test.o test.s
```
<img width="703" alt="image" src="https://user-images.githubusercontent.com/56042451/193446080-3d0a3cf2-4465-4c01-b861-1de4456d50ec.png">


### 5. Linkng
생성된 목적파일들을 연결하는 작업이다. 여러 작업들을 분할했다면 이 과정에서 관련있는 서로의 파일들이 엮이게 된다. 또한 정적라이브러리도 여기서 합쳐지게 된다. 이 과정을 마무리로 실행파일(.out, .exe ...)가 생기게된다.

```c
$ gcc -o a.out test.o
```

## Process comunication
프로세스는 시스템내에서 독립적으로 실행되기도 하지만, 서로 데이터를 주고받으며 협업하기도 한다. 데이터를 주고받을 때는 프로세스끼리 통신을 해야한다. 또한 프로세스 내부에서 스레드끼리 통신이 가능하고, 소켓을 이용하여 각 호스트의 프로세스끼리도 통신이 가능하다.

### 1. 통신종류
* 프로세스 내 통신
  + 하나의 프로세스에서 두 개 이상의 스레드가 존재하는 경우 프로세스 내부에서 스레드 끼리 데이터를 주고받는 경우.
    - 전역변수 또는 파일 사용
* 프로세스 간 통신
  + 같은 시스템 내에서 두 개 이상의 프로세스 끼리 통신하는 경우
    - 메모리를 사용 (메인메모리: shared memory, 보조메모리: 파일, pipe(내부적으로파일))
* 네트워크를 이용한 통신
  + 여러 컴퓨터 간 네트워크로 연결되어 있는 경우
    - 소켓 사용, 원격 프로시져 호출(RPC)

프로세스 간 통신(Inter Process Comunication)이 스레드를 이용한 프로세스 내 통신 보다 어려운 이유?
스레드는 서로 메모리와 자원을 공유하기 때문에 같은 변수에 접근이 가능하다. 하지만 프로세스는 서로 다른 메모리 공간을 사용하기 때문에 별도의 공간을 만들어서 데이터 통신을 해야하기 때문에 프로세스 간 통신이 어렵다.

### 2. 통신 방향의 분류
통신 장치들은 데이터가 전송되는 방향에 따라 각기 불리는 이름이 다르다.

#### 2-1. 양방향 통신(Duplex communication)
양방향 통신은 동시에 양쪽 방향으로 전송할 수 있는 구조이다. 양방향을 구현하기 위해서는 변수가 두 개 있어야 가능하다. 1개만 사용하면 동시에 보낼 시 빨리온 데이터는 늦게온 데이터에 덮혀 쓰여지기 때문이다.

#### 2-2. 단방향 통신 (simplex communication)
단방향 통신은 한쪽 방향으로만 데이터를 전송할 수 있는 구조. 한쪽은 데이터를 무조건 보내고 한 쪽은 데이터를 무조건 받기만 한다.

#### 2-3. 반양방향 통신 (half-duplex communication)
반양방향 통신은 양쪽 방향으로 데이터 전송이 가능하지만, 동시 전송이 불가능한 형대이다. 한쪽에서 데이터를 보내고 있다면 한쪽에서는 데이터 전송 행위가 불가능 하다.

## Process
### 1. 개념
process란 메모리에서 현재 실행 중인 프로그램을 의미한다. 즉, 파일 형태의 프로그램이 실행되어 메모리 상에 적재되어 실행되면 프로세스가 되는 것이다. 리눅스에서는 프로세스보다는 task라는 말로 쓰인다.

### 2. 프로세스의 관리
프로세스 단위로 os에서는 스케줄링(프로세스 순서를 결정하는 행위)을 하거나 자원을 할당한다. 프로세스를 관리하기 위해서는 프로세스를 하나의 자료단위로 표현해야한다. 리눅스에서는 프로세스를 자료구조료 표현한 객체를 task descriptor라고 부르고, 실제 리눅스 코드를 보면 task_struct 구조체로 표현되어있다. task_struct에는 프로세스 단위로 관리해야할 여러가지(메모리 리소스, 프로세스 이름, 프로세스 ID ...)가 저장되어 있다. 운영체제에서는 일반적인 용어로 task_struct를 PCB(Process Control Block)이라 부른다

#### Systemmd
init 프로세스에서 이름이 변경된 프로세스로 유저 공간에서 생성된 프로세스의 부모 프로세스 역할을 수행한다.

## 명령어

### echo

#### 1. 설명
인자로 전달된 text/string을 표시하기 위한 명령어. 대부부 shellscript나 batch file에서 사용한다.
```bash
echo [option] [string]
```

### 2. 옵션
#### -e : 백슬래쉬의 해석을 가능하게 하는 옵션

1. \n
2. \r

## 부트로더
### 부트로더란?
운영체제는 자신이 직접 실행될 수 없다. 기본적으로 프로그램이 실행되기 위해서는 주메모에 적재되어야 한다. CPU는 이차메모리와 직접 통신하지 않고 주메모리와 통신하기 때문이다. 프로그램은 운영체제가 메모리에 적하는데 운영체제는 누가 적제하는가? 바로 부트로더란 소형 프로그램이 운영체제를 메모리에 적재하여 운영체제를 실행하게 한다.

### 운영체제 메모리 적재과정
컴퓨터에 전원이 들어오면 메인보드에 장착되어 있는 ROM이라는 비휘발성 메모리에 있는 BIOS라는 소프트웨어가 작동한다. 바이오스는 기본적인 시스템에 모든 장치를 초기화하고 운영체제를 적재하는 프로그램을 메모리에 적재하는 일을 한다. 즉 모든 프로그램에 시발점은 바이오스이다.  
바이오스는 운영체제를 실행시킬 수 있는 소형 프로그램(부트로더)를 2차 메모리 장치에서 찾아 메모리에 적재한다. 그런다음 부트로더는 운영체제의 커널을 메모리에 적재하게 된다.  
![image](https://user-images.githubusercontent.com/56042451/200335183-4ea06449-70c2-4f63-9c21-7f8d48d9b232.png)

### 바이오스는 어떻게 부트로더의 위치를 찾나?
바이오스는 모든 연결된 2차메모리 장치를 확인한다. 0번 섹터의 데이터이 512바이트를 확인하고 512바이트의 마지막 데이터가 0xAA55로 끝난다면 부트로더라고 판단하고 메모리 0x07C0번지에 적재하게 된다. 만약 0xAA55로 끝나지 않으면 부트로더가 아닌 것이다. 부트로더가 적재되는 메모리 위치 0x07c0와 부트로더 판단 매직넘버 0xAA55 약속이므로 의미를 부여할 필요는 없다. 부트로더가 있는 디스크의 0번 섹터는 MBR(Master Boot Record)라고 부른다. 운영체제를 실행시키는 코드 외 파티션을 구분하는 코드가 있다. 실질적인 부트로더는 446바이트를 사용하고 64바이트는 파티션의 관한 코드 2바이트는 매직넘버(0xAA55)이다.  
![image](https://user-images.githubusercontent.com/56042451/200336514-3d86d9a5-8271-4ad3-b122-f74a544fdd3b.png)

### 

## 리얼모드
### 1. 개념
리얼 모드는 약간의 계산으로 논리주소를 바로 물리주소에 매핑하는 방법이다. Intel 80286 이전 8086, 8088 프로세서에서 사용되던 방식이다. 80286 이후 보호모드라는 개념이 생기면서 이 방법이 리얼모드라고 지칭되었다. 당시 프로세서는 16bits 명령어 사용과 최대 1MB(20bits) 메인메모리를 사용했다. MS-DOS 같은 운영체제 시스템은 리얼모드로만 동작했다. 당시 1MB는 상당히 큰 메모리였고 IBM에서는 사용자에게 640KB만을 사용할 수 있도록 제약했다. 나머지는 공간은 커널 코드를 위한 공간이다.
![image](https://user-images.githubusercontent.com/56042451/200291356-12bd3a7c-aae9-4a9e-9ef2-3c5e0f7d727c.png)  
![image](https://user-images.githubusercontent.com/56042451/200298834-df2eaa57-e464-41c5-b263-162ade08abd6.png)


### 2. 리얼모드의 문제점
첫 번째로 프로그램이 한번에 한 개만 동작한다는 것이다. 현재 시스템에서는 싱글 프로세서에서도 여러 프로그램이 동시에 작동한다. 이것은 메모리 분할 기법과 관련이 있지만 리얼모드에서는 메모리 분할 기법이 없다. 단, 직접 메모리에 프로그램의 명령어를 상주하게 하므로써 접근하여 실행한다. 두 번째는 다른 영역에 침법가능성이다. 현재 프로그램이 아무리 잘못만들어져도 OS의 코드나 다른 시스템 코드에 접근하지는 못한다. 접근하려면 시스템 콜을 호출해야한다. 하지만 리얼모드는 직접 물리 메모리에 접근이 가능하기 때문에 다른 시스템 코드를 잘못 수정하여 에러 발생가능성이 존재했다.

### 3. 물리주소로 매핑
리얼모드에서는 16bits를 프로세서를 사용한다고 했다. 하지만 16비트는 최대 2^16 크기의 메모리만 사용가능 한데 1MB이라는 것은 말이 되지 않는다. 이를 해결하기 위해 범용 레지스터를 이용하여 20비트 크기를 사용한다. 범용 레지스터의 4bits 크기를 이용한다. 물리 주소 매핑 방식은 세그먼트:오프셋 방식이다. 세그먼트를 왼쪽으로 4비트 만큼 옳기고 오프셋을 더하여 물리주소를 계산한다.

# Create OS
## 1. 부트로더 작성



