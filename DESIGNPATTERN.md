# 5principles of oop

## SRP(Single-responsibility principle)

### 개념
>단일 책임 원칙은 클래스, 모듈, 함수 등 모든 하나의 책임, 목적을 하는 것이다.  
>every class should have only one reason to change


<br></br>
## Iterator Pattern(반복자 패턴)
### ■ 개념 
보통 모든 배열 또는 컨테이너를 원소 0번에서 n-1번까지 반복하기 위해 **for(int i = 0; i < n; i++)** 로 반복한다. 반복자 패턴은 반복문에서 변수 i의 기능을 추상화한 패턴이다. 

### ■ 반복자 패턴은 장점은?
단순히 추상화해서 내부 구현을 외부로 누출되지 않다는 것은 반복자 패턴 뿐만 아니라 모든 패턴이 지향해야하는 관점이다. 내가 사용한 반복자 패턴의 강점은 컨테이너의 원소를 삭제할 경우이다. 단순한 반복문으로 해당 컨테이너의 원소를 삭제하게되면 제대로된 삭제가 되지 못하거나 에러를 발생시킬 수 있다. 내부적으로 컨테이너의 모양이 변경되는 경우가 다수 있기 때문이다. 그렇기에 단순 반복문으로 삭제하면 많은 에로사항이 따른다. 하지만 Iterator를 이용하여 삭제할 경우 코드가 매우 단순하고 에러를 다루를 코드를 따로 생각할 필요가 없다. 반복자의 함수는 매우 명확하게 작성되어 그 기능을 최대한 활용하면 코드의 간결성이 높아진다. 또한 반복하는 방법이 단순 순회가 아니라 전위 순회, 중위 순회처럼 다른 방법으로 동작해야한다면 사용자가 구현할 필요없이 반복자의 반복 알고리즘을 작성하여 사용자가 반복하는 방법을 구현하지 않아도 된다.

### ■ 구조
<p align="center"><img width="496" alt="image" src="https://user-images.githubusercontent.com/56042451/209600598-80f43972-cb8f-4a85-92db-46522c09d3fb.png"></p> 

* Aggregate : 반복자를 생성해준다. 왜 인터페이스냐? vector같은 컨테이너에 반복자를 생성해주는 것을 강제화 시키고 틀을 잡아놓으면 개편하겠지? 왜냐? 컨테이너는 벡터 말고도 여러개 만들어 질게 분명하거든!
* BookShelf(ConcreteAgreegate) : Aggregate를 구체화시키는 클래스로 흔히 vector, queue같은 컨테이너이다.
* Iterator : 반복자에 대한 틀이다. 왜 인터페이스냐? 반복자가 가지는 변수가 concreteAggregate마다 다르기 그냥 인터페이스로 가져야할 메소드를 강제화 시키는 것이 좋다.
* BookShelfIterator(ConcreteIterator) : Iterator를 BookShelf에 맞게 구체화 시킨 클래스이다. 벡터면 벡터반복자, 큐면 큐반복자. 구체화된 반복자와 구체화된 집약은 나름 강하게 연결되어 있지만 인터페이스 간에는 남남이다.

<br></br>
## Adapter Parttern(적응자 패턴, Wrraper Pattern)
### ■ 개념
적응자 패턴은 기존의 것을 새로운 것으로 적용시키기 위해 변화시키는 패턴이다. 예를 들어 12볼트로 작동되는 전자기기를 100볼트 콘센트의 꼽을 시 전자기기는 망가질 것이다. 이를 방지하기위해 보통은 어댑터라는 것을 사용하여 100볼트 전원장치를 12볼트로 변환시킨다. 이때 어댑터가 어댑터 패턴의 어댑터이다. 어댑터 패턴도 이와같이 기존의 것을 그대로 사용하면서 새로운 것을 만들거나 새로운 것에 맞추어 기존에 것을 구동시키는 것에 목적이 있다. 

### 구조
#### 위임을 이용한 구조
<p align="center"><img width="710" alt="image" src="https://user-images.githubusercontent.com/56042451/209745221-579c2ba0-962e-4e21-8c13-6022a4d7fb20.png"></p>

#### ⃞ 상속을 이용한 구조

#### ⃞역할
* Client : 어댑터 패턴을 사용하는 사람을 의미한다.
* Target : 클라이언트가 원하는 기능의 초안을 만드는 작업(인터페이스)이다.
* Adapter : Target의 동작을 구체적으로 구현한 클래스이며 실질적인 구동역할의 중추이다.
* Adaptee : 기존의 기능이 있는 클래스이다.

### 어댑터 패턴의 구현 방식
어댑터 패턴은 두 가지 구현 방식으로 나뉜다. 상속을 이용해서 구현할 수도 있고 위임을 이용하여 구현 할 수 도있다.

#### ⃞ 상속을 이용한 구현
상속은 간단하다. Adapter 클래스가 Adaptee 클래스를 상속하여 클라이언트가 원하는 기능을 추가하여 구현하면 된다. 그럼 왜 굳이 Target을 두어 복잡하게 만드나? 상속해서 바로 사용하면 되지 않나? 만약 클라이언트가 상속받은 것을 바로 쓰게 되면 부모 클래스인 Adaptee클래스의 메소드에 모든 접근해버린다. 그러면 클라이언트는 자신이 원하지 않는 기능을 보게되고 클라이언트가 원하지 않는 기능도 실수로 사용해버릴 가능성도 있다. 이를 막기위해 인터페이스로 사용자가 원하는 기능만 접근할 수 있도록 강제하면 사용자는 딱 원하는 기능만 사용할 수 있을 것이다. 즉 사용자는 어댑터 인스턴스를 사용하기위해 target A = new Adapter()로 사용해야한다. 

#### ⃞ 위임을 이용한 구현
위임도 상속과 거의 비슷하다. 그럼 상속을 사용하면 되지 왜 굳이 위임도 따로 두어 사람 머리를 아프게 만드는 것 일까? 나도 나름 깊게 생각해보았는데 Adaptee가 변경 할 일이 있으면 사용하는 것 같다. 만약 메일 전송기능을 구현한 클래스가 있다고 가정하자. 이 클래스를 상속하여 만든 삼성전자 메일전송 클래스, 구글 메일전송 클래스 등 총 10개의 각 회사별 메일 전송 클래스가 있다고 하자. 어떤 고객이 기존 메일에 마지막 문단에 자신의 시그니처 표현을 붙이고 싶다고하고 어댑터 패턴으로 구현해주길 바란다. 그럼 각 회사별로 상속을 이용한 어댑터를 만들게되면 어댑터가 10개이다. 그러면 개발자는 각 회사별 Target기능을 구현해야한다. 사용자도 10가지 어댑터가 있으므로 불편하다. 하지만 위임을 이용하여 구현하게되면 타겟에 대한 정의를 한 번만하고 어댑터 클래스도 하나만 만들 수 있다. 사용자는 하나의 어댑터로 Adaptee만 변경하여 사용가능하다. 쉽게 노트북으로 비교하면 삼성전자 노트북, Lg노트북, 애플 노트북들의 전원장치를 상속의 경우는 각 회사별 전원장치를 만드는 것이고 위임은 하나의 어댑터로 모든 노트북의 전원장치로 쓴느 것이다.  


<br></br>
## Template Method Pattern
### ■ 개념
이름에서 알 수 있듯 견본, 형판, 틀(template) + 방식(Method)를 가진것을 보아 특정 형태를 포함한 함수(멤버함수= 메소드)를 만드는 패턴이라고 할 수 있다. 템플릿 메소드 패턴은 상위클래스에서 각 로직들의 동작 흐름을 강제화하고 하위클래스에서 각 로직의 구체적인 동작 방식을 정의 하도록 하는 것을 의미한다. 

### ■ 구조 
<p align="center"><img width="362" alt="image" src="https://user-images.githubusercontent.com/56042451/209894585-4c20dc28-960e-4fb3-aa21-f80706e72272.png"></p>

####  ⃞ AbstractClass
부모클래인 추상클래스의 templateMethod 함수가 각 알고리즘들의 흐름을 정의한 것이다. 위에서 각 알고리즘은 stepN()함수들이 된다. step 함수들은 추상 메소드로 하위 클래스에서 반드시 오버라이드 해야한다.

####  ⃞ ConcreteClass
구현 클래스는 추상클래스를 상속받아 각 알고리즘들을 구현해야한다. 


<br></br>
## Factory Method Pattern
### ■ 개념
템플릿 메소드가 패턴이 무엇이었나? 특정 흐름을 구성한 템플릿 메소드가 있고 흐름에 영향을 미치는 각 알고리즘은 하위클래스에서 구성해야했다. 일단 이것을 꼭 기억하자. Factory는 공장에서 찍어내는 것처럼 프로그래밍 언어에서는 인스턴스를 찍어내는 역할을 한다. 어떨때 고려해볼 수 있나? 보통 인스턴스를 만들때 매개변수가 많거나 인스턴스를 만들때 특정 로직을 필수로 넣어야 할 때이다. 매개변수가 많으면 사용자가 인스턴스를 만들때마다 불편할 것이다. 특정 로직을 넣어야하는 경우는 만약 유서 인스턴스를 생성하는 클래스가 있다면 인스턴스 생성과정에서 아이디 패스워드만 받는 것이아닌 아이디 중복이나 패스워드가 일치하는지 등 다양한 인증과정을 거쳐야한다. 이때 생성하는 클래스에서 해당 인스턴스를 생성시 인증과정의 흐름을 필수적으로 정의할 수 있다. 흐름을 정의한다. 인증을 세부구현은 사용자가 한다. 어디서 들어보지 않았나? 바로 템플릿 메소드이다. 팩토리 메소드는 템플릿 메소드를 응용한다.

### ■ 구조
<p align="center"><img width="663" alt="image" src="https://user-images.githubusercontent.com/56042451/210026451-91cd50f2-a7b9-4919-a5f7-a6f79dda9450.png"></p>

####  ⃞ AbstractFactory
팩토리 메소드 패턴을 추상화한다. 어떤 인스턴스를 생성할 지는 concreteFactory에서 정의한다. AbstractFactory에는 템플릿 메소드를 응용해서 팩토리 메소드가 인스턴스 생성 후 인증 같은 과정을 처리하기도 한다.

####  ⃞ ConcreteFactory
팩토리 메소드를 구체화한다. 

####  ⃞ Product
제품이 가져야할 기능을 추상화 한다.

####  ⃞ ConcreteProduct
제품 가져야할 기능을 구체화한다. 구체화된 제품은 ConcreteFactory에서 인스턴스를 생성한다.

<br></br>
## Prototype Pattern
### ■ 개념
프로토타입 패턴은 객체의 생성 비용이 많이 들거나 유사한 객체를 만드는 경우에 보통 사용하게 된다. 객체를 새로 생성하는 것이 아닌 기존의 객체를 복사하여 만드는 것이다.

####  ⃞ 객체 생성비용?
데이터베이스에서 SQL쿼리로 질의를 할 경우를 생각해보자. A라는 함수에서 데이터베이스에 질의해서 데이터를 반환 받았고 함수내에서 여러 처리 과정을 거친다. B라는 함수에서도 A와 같은 질의로 데이터를 처리하는 과정을 거친다. 사용자는 A함수와 B함수를 연속적으로 사용하고자 한다. 그럼 데이터베이스에 접근하는 횟수는 몇번인가? 2번이 되게 된다. 2번 데이터베이스에 접근하여 반환된 데이터 객체를 각 함수에서 처리하게 되는 것이다. 만약 AB라는 함수를 연속적으로 3번 호출하면 총 6번의 데이터 객체가 생성된다. 이러면 함수를 호출하면 할수록 성능은 저하게된다. 여기서 포인트는 A함수와 B함수는 동일한 질의를 하는 것이다. 즉 처리하는 데이터가 같다. A라는 함수에서 받아온 데이터를 B함수에서도 이용해서 처리한다면 데이터베이스에 1번 접근만으로도 두 함수의 처리를 모두 가능하게 한다. B는 A함수에서 받아온 데이터 객체를 복사하여 처리하면 효과적이다.

####  ⃞ 유사한 객체?
파워포인트에서 사각형을 생성한다음 동일한 사각형을 또 생성하려할때 새로 사각형을 생성하고 채우기, 선두깨 등을 처리하는 것이 빠른가 아니면 기존의 사각형을 복사하여 생성하는게 빠른가? 복사, 붙여넣기 기능을 안다면 기존의 사각형을 복사하여 생성하는게 빠르다는 것을 알고있다. 이것이 프로토타입 패턴이다. 기존의 사각형을 복사하여 채우기, 선두께 등을 처리하지 않아 사각형 생성비용이 현저히 낮아졌다. 

####  ⃞ 리눅스에서 프로토타입과 유사한 행동?
리눅스에서 프로세스를 생성할 때는 새로운 프로세스를 생성하는 속도보다 기존의 부모 프로세스를 복사하는 것이 빠르다. 새롭게 프로세스를 생성하면 메모리, CPU 등등 관련 자원등을 설정해야하는 반면 기존의 프로세스를 복사하게되면 여러 자원 설정 등을 하지 않아도 되기 때문에 프로세스를 생성하기 보다는 기존의 것을 복사한다. 

### ■ 구조
####  ⃞ 일반적인 구조
<p align="center"><img width="567" alt="image" src="https://user-images.githubusercontent.com/56042451/210128734-e0042a3e-91ea-40a7-92fe-0c163c94a74f.png"></p>

####  ⃞ 팩토리 패턴와 결합한 구조
<p align="center"><img width="824" alt="image" src="https://user-images.githubusercontent.com/56042451/210128911-26160485-8b89-4725-ab29-edbb74bd175a.png"></p>

* Prototype : 프로토타입 객체로 상속받은 객체에서 복사(Clone)메소드를 구현해야한다.
* ConcretePrototype : 복사 메소드를 구체적으로 구현하는 클래스.
* Client : 클라이언트가 단순히 ConcretePrototype 클래스를 사용할 수도 있고, 각 ConcretePrototype을 생성해주는 팩토리 패턴을 이용하여 클라이언트에 사용을 강제화 할 수도 있다.


<br></br>
## Builder Pattern
### ■ 빌더 패턴이란?
빌더 패턴은 인스턴스를 생성할 객체의 매개변수가 많이 포함되어 있는 팩토리, 추상팩토리 패턴의 결함을 해결하기 위해 소개된 패턴이다. 객체를 생성하기 위해 인자값이 많으면 왜 좋지 못한가?
* 클라이언트 측에서 인자들의 타입을 파악하기 쉽지 않다. 
* 매개변수가 많음에도 클라이언트에서 강제로 인자값을 넣어야한다. 만약 클라이언트에서 필요없다고 생각하는 인자면 null이라도 넣어야한다.
매개변수가 많아서 객체 생성에 어려움이 있는 경우 우리는 setter 메소드를 추가하여 해결할 수 있다. 하지만 이 방법은 매우 좋지 못하다. 클라이언트에 객체에 생성에 대한 모든 것을 setter로 지정하게 하면  초기의 객체 생성이 일정하지 못하다는 단점이 있다. 만약 초기값들을 지정하지 않을 경우 null로 설정되어야 정확히 프로그램이 있다고 하면 사용자가 setter로 지정할 것이랑 생각으로 인해 아무것도 하지 않게되면 쓰레기 값이 들어가 버그를 일으킬 수도 있는 문제이다. 물론 자바에서는 초기화를 자동으로 진행해서 문제 없겠지만 C++에서는 초기화를 개발자가 정의하지 않으면 쓰레기 값으로 초기화가 되기 때문에 매우 중요한 문제이다. 빌더 패턴은 일정하지 못한 객체 생성을 막기위해 단계적으로 객체들의 모든 속성들을 초기화하여 사용자에게 제공한다. 

### ■ 구조
<p align="center"><img width="644" alt="image" src="https://user-images.githubusercontent.com/56042451/210190831-79d9b54a-0319-46f5-9fef-440a701e4144.png"></p>




