# 5principles of oop

## SRP(Single-responsibility principle)

### 개념
>단일 책임 원칙은 클래스, 모듈, 함수 등 모든 하나의 책임, 목적을 하는 것이다.  
>every class should have only one reason to change


<br></br>
## Iterator Pattern(반복자 패턴)
### ■ 개념 
보통 모든 배열 또는 컨테이너를 원소 0번에서 n-1번까지 반복하기 위해 **for(int i = 0; i < n; i++)** 로 반복한다. 반복자 패턴은 반복문에서 변수 i의 기능을 추상화한 패턴이다. 

### ■ 반복자 패턴은 장점은?
단순히 추상화해서 내부 구현을 외부로 누출되지 않다는 것은 반복자 패턴 뿐만 아니라 모든 패턴이 지향해야하는 관점이다. 내가 사용한 반복자 패턴의 강점은 컨테이너의 원소를 삭제할 경우이다. 단순한 반복문으로 해당 컨테이너의 원소를 삭제하게되면 제대로된 삭제가 되지 못하거나 에러를 발생시킬 수 있다. 내부적으로 컨테이너의 모양이 변경되는 경우가 다수 있기 때문이다. 그렇기에 단순 반복문으로 삭제하면 많은 에로사항이 따른다. 하지만 Iterator를 이용하여 삭제할 경우 코드가 매우 단순하고 에러를 다루를 코드를 따로 생각할 필요가 없다. 반복자의 함수는 매우 명확하게 작성되어 그 기능을 최대한 활용하면 코드의 간결성이 높아진다. 또한 반복하는 방법이 단순 순회가 아니라 전위 순회, 중위 순회처럼 다른 방법으로 동작해야한다면 사용자가 구현할 필요없이 반복자의 반복 알고리즘을 작성하여 사용자가 반복하는 방법을 구현하지 않아도 된다.

### ■ 구조
<p align="center"><img width="496" alt="image" src="https://user-images.githubusercontent.com/56042451/209600598-80f43972-cb8f-4a85-92db-46522c09d3fb.png"></p> 

* Aggregate : 반복자를 생성해준다. 왜 인터페이스냐? vector같은 컨테이너에 반복자를 생성해주는 것을 강제화 시키고 틀을 잡아놓으면 개편하겠지? 왜냐? 컨테이너는 벡터 말고도 여러개 만들어 질게 분명하거든!
* BookShelf(ConcreteAgreegate) : Aggregate를 구체화시키는 클래스로 흔히 vector, queue같은 컨테이너이다.
* Iterator : 반복자에 대한 틀이다. 왜 인터페이스냐? 반복자가 가지는 변수가 concreteAggregate마다 다르기 그냥 인터페이스로 가져야할 메소드를 강제화 시키는 것이 좋다.
* BookShelfIterator(ConcreteIterator) : Iterator를 BookShelf에 맞게 구체화 시킨 클래스이다. 벡터면 벡터반복자, 큐면 큐반복자. 구체화된 반복자와 구체화된 집약은 나름 강하게 연결되어 있지만 인터페이스 간에는 남남이다.

<br></br>
## Adapter Parttern(적응자 패턴, Wrraper Pattern)
### ■ 개념
적응자 패턴은 기존의 것을 새로운 것으로 적용시키기 위해 변화시키는 패턴이다. 예를 들어 12볼트로 작동되는 전자기기를 100볼트 콘센트의 꼽을 시 전자기기는 망가질 것이다. 이를 방지하기위해 보통은 어댑터라는 것을 사용하여 100볼트 전원장치를 12볼트로 변환시킨다. 이때 어댑터가 어댑터 패턴의 어댑터이다. 어댑터 패턴도 이와같이 기존의 것을 그대로 사용하면서 새로운 것을 만들거나 새로운 것에 맞추어 기존에 것을 구동시키는 것에 목적이 있다. 

### 구조
#### 위임을 이용한 구조
<p align="center"><img width="710" alt="image" src="https://user-images.githubusercontent.com/56042451/209745221-579c2ba0-962e-4e21-8c13-6022a4d7fb20.png"></p>

#### ⃞ 상속을 이용한 구조

#### ⃞역할
* Client : 어댑터 패턴을 사용하는 사람을 의미한다.
* Target : 클라이언트가 원하는 기능의 초안을 만드는 작업(인터페이스)이다.
* Adapter : Target의 동작을 구체적으로 구현한 클래스이며 실질적인 구동역할의 중추이다.
* Adaptee : 기존의 기능이 있는 클래스이다.

### 어댑터 패턴의 구현 방식
어댑터 패턴은 두 가지 구현 방식으로 나뉜다. 상속을 이용해서 구현할 수도 있고 위임을 이용하여 구현 할 수 도있다.

#### ⃞ 상속을 이용한 구현
상속은 간단하다. Adapter 클래스가 Adaptee 클래스를 상속하여 클라이언트가 원하는 기능을 추가하여 구현하면 된다. 그럼 왜 굳이 Target을 두어 복잡하게 만드나? 상속해서 바로 사용하면 되지 않나? 만약 클라이언트가 상속받은 것을 바로 쓰게 되면 부모 클래스인 Adaptee클래스의 메소드에 모든 접근해버린다. 그러면 클라이언트는 자신이 원하지 않는 기능을 보게되고 클라이언트가 원하지 않는 기능도 실수로 사용해버릴 가능성도 있다. 이를 막기위해 인터페이스로 사용자가 원하는 기능만 접근할 수 있도록 강제하면 사용자는 딱 원하는 기능만 사용할 수 있을 것이다. 즉 사용자는 어댑터 인스턴스를 사용하기위해 target A = new Adapter()로 사용해야한다. 

#### ⃞ 위임을 이용한 구현
위임도 상속과 거의 비슷하다. 그럼 상속을 사용하면 되지 왜 굳이 위임도 따로 두어 사람 머리를 아프게 만드는 것 일까? 나도 나름 깊게 생각해보았는데 Adaptee가 변경 할 일이 있으면 사용하는 것 같다. 만약 메일 전송기능을 구현한 클래스가 있다고 가정하자. 이 클래스를 상속하여 만든 삼성전자 메일전송 클래스, 구글 메일전송 클래스 등 총 10개의 각 회사별 메일 전송 클래스가 있다고 하자. 어떤 고객이 기존 메일에 마지막 문단에 자신의 시그니처 표현을 붙이고 싶다고하고 어댑터 패턴으로 구현해주길 바란다. 그럼 각 회사별로 상속을 이용한 어댑터를 만들게되면 어댑터가 10개이다. 그러면 개발자는 각 회사별 Target기능을 구현해야한다. 사용자도 10가지 어댑터가 있으므로 불편하다. 하지만 위임을 이용하여 구현하게되면 타겟에 대한 정의를 한 번만하고 어댑터 클래스도 하나만 만들 수 있다. 사용자는 하나의 어댑터로 Adaptee만 변경하여 사용가능하다. 쉽게 노트북으로 비교하면 삼성전자 노트북, Lg노트북, 애플 노트북들의 전원장치를 상속의 경우는 각 회사별 전원장치를 만드는 것이고 위임은 하나의 어댑터로 모든 노트북의 전원장치로 쓴느 것이다.  

<br></br>
## Template Method Pattern
### ■ 개념
이름에서 알 수 있듯 견본, 형판, 틀(template) + 방식(Method)를 가진것을 보아 특정 형태를 포함한 함수(멤버함수= 메소드)를 만드는 패턴이라고 할 수 있다. 템플릿 메소드 패턴은 상위클래스에서 각 로직들의 동작 흐름을 강제화하고 하위클래스에서 각 로직의 구체적인 동작 방식을 정의 하도록 하는 것을 의미한다. 

### ■ 구조 
<p align="center"><img width="362" alt="image" src="https://user-images.githubusercontent.com/56042451/209894585-4c20dc28-960e-4fb3-aa21-f80706e72272.png"></p>

#### AbstractClass
부모클래인 추상클래스의 templateMethod 함수가 각 알고리즘들의 흐름을 정의한 것이다. 위에서 각 알고리즘은 stepN()함수들이 된다. step 함수들은 추상 메소드로 하위 클래스에서 반드시 오버라이드 해야한다.

#### ConcreteClass
구현 클래스는 추상클래스를 상속받아 각 알고리즘들을 구현해야한다. 





